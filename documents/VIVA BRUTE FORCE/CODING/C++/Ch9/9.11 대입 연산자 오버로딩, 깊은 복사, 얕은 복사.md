# 9.11 대입 연산자 오버로딩, 깊은 복사, 얕은 복사



```C++

#include <iostream>
#include <cassert>

using namespace std;


class MyString {
public:
    char *m_data = nullptr;
    int m_length = 0;

public:
    MyString(const char *source = "") {
        assert(source);

        // null charater를 추가히가 위해    + 1
        m_length = std::strlen(source) + 1;
        m_data = new char[m_length];

        for (int i = 0; i < m_length; ++i) {
            m_data[i] = source[i];
        }

        m_data[m_length - 1] = '\0';
    }


    MyString(const MyString &source) {
        cout << "Copy constructor " << endl;

        m_length = source.m_length;

        if (source.m_data != nullptr) {
            m_data = new char[m_length];

            for (int i = 0; i < m_length; ++i) {
                m_data[i] = source.m_data[i];
            }
        } else {
            m_data = nullptr;
        }
    }

    MyString &operator=(const MyString &source) {
        cout << "Assignment operator " << endl;

        if (this == &source) {  // prevent self-assignment
            return *this;
        }

        delete[] m_data;
        m_length = source.m_length;

        if (source.m_data != nullptr) {
            m_data = new char[m_length];

            for (int i = 0; i < m_length; ++i) {
                m_data[i] = source.m_data[i];
            }
        } else {
            m_data = nullptr;
        }

        return *this;

    }


    ~MyString() {
        delete[] m_data;
    }

    char *getString() { return m_data; };

    int getLength() { return m_length; }

};

int main() {

    MyString hello("Hello");

    // 0x7fe369c00340
    cout << (int *) hello.m_data << endl;
    // Hello
    cout << hello.getString() << endl;

    {
        MyString copy = hello;
        cout << (int *) copy.m_data << endl;
        cout << copy.getString() << endl;
    }


    // 얕은 복사라면 여기서 문제가 발생한다.
    cout << hello.getString() << endl;


    // Copy constructor
    MyString str1 = hello;

    // 여기서 한번 생성자가 호출되고, 다음 줄에서 대입 연산자가 호출된다.
    MyString str2;
    // Assignment operator
    str2 = hello;


    return 0;
}

```

