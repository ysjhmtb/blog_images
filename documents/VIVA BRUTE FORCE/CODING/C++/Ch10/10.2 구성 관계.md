# 10.2 구성 관계



```C++
// Position2D.h

#ifndef DEC_POSITION2D_H
#define DEC_POSITION2D_H

#include <iostream>

class Position2D {
private:
    int m_x;
    int m_y;

public:
    Position2D(const int &x_in, const int &y_in)
            : m_x(x_in), m_y(y_in) {}

    // TODO : overload operator =


    void set(const Position2D &pos_target) {
        set(pos_target.m_x, pos_target.m_y);
    }

    void set(const int &x_target, const int &y_target) {
        m_x = x_target;
        m_y = y_target;
    }

    friend std::ostream &operator<<(std::ostream &out, const Position2D &pos2d) {
        out << pos2d.m_x << " " << pos2d.m_y << std::endl;
        return out;
    }

};

#endif //DEC_POSITION2D_H

```

<br>

```C++
// Monster.h



#ifndef DEC_MONSTER_H
#define DEC_MONSTER_H

#include <string>
#include "Position2D.h"

class Monster {

private:
    std::string m_name;
    Position2D m_location;

//    int m_x;
//    int m_y;

public:
    Monster(const std::string name_in, const Position2D &pos_in)
            : m_name(name_in), m_location(pos_in) {}

    void moveTo(const Position2D &pos_target) {
        m_location.set(pos_target);

//        m_x = x_target;
//        m_y = y_target;
    }

    // 반환형이 std::ostream & 이 아니라 std::ostream 이면 다음과 같은 에러 발생.
    //
    // error: call to deleted constructor of 'std::ostream' (aka 'basic_ostream<char>')
    //        return out;
    //
    friend std::ostream &operator<<(std::ostream &out, Monster &monster) {
        out << monster.m_name << "  " << monster.m_location << std::endl;
        return out;
    }


};


#endif //DEC_MONSTER_H

```

<br>

```C++
// main.cpp


#include "Monster.h"

using namespace std;


int main() {


    Monster mon1("Sanson", Position2D(0, 0));
    cout << mon1 << endl;

    Monster mon2("Parsival", Position2D(0, 0));


    {
        // event
        mon1.moveTo(Position2D(1, 1));
        cout << mon1 << endl;

    }

    return 0;
}

```

