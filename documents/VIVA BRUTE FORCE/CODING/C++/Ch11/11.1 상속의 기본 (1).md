# 11.1 상속의 기본 (1)



```C++

// main.cpp

#include <iostream>

using namespace std;

class Mother {
private:
    int m_i;

public:

    Mother(const int &i_in)
            : m_i(i_in) {
        std::cout << "Mother constructor " << endl;
    }

    void setValue(const int &i_in) {
        m_i = i_in;
    }

    int getValue() {
        return m_i;
    }

};


class Child : public Mother {
private:
    double m_d;

public:

    /*
     Child(const int& i_in, const double& d_in)
        :m_i(i_in), m_d(d_in)
        {

        }
     이와 같은 생성자는 불가능하다. 이 상황에서는 m_i라는 메모리가 존재하지 않는다.

     */

    Child(const int &i_in, const double &d_in)
            : Mother(i_in), m_d(d_in) {
//        Mother::setValue(i_in);
//        m_d = d_in;
    }

    void setValue(const int &i_in, const double &d_in) {
        Mother::setValue(i_in);
        m_d = d_in;

    }

    void setValue(const double &d_in) {
        m_d = d_in;
    }

    double getValue() {
        return m_d;
    }


};

//class Daughter : public Mother {
//
//};
//
//class Son : public Mother {
//
//};

int main() {

    Mother mother(1024);
//    mother.setValue(1024);
    cout << mother.getValue() << endl;

    Child child(1024, 128);
//    child.Mother::setValue(1024);
//    child.setValue(128);

    cout << child.Mother::getValue() << endl;
    cout << child.getValue() << endl;


    return 0;
}

```

