# 19.4 레이스 컨디션, std::atomic, std::scoped_lock



```C++
 
// main.cpp

/*
     멀티 스레딩은 여러 개의 스레드들이 하나의 메모리 공간을 함께 사용할 수 있게 해주기 때문에 다른 병렬처리 기법들에 비해서
     훨씬 구현하기가 편리하다. 그러나 같은 메모리 공간을 공유할 수 있다는 장점이 오류를 발생시키는 단점이 될 수도 있으며
     이를 race condition이라고 한다.
*/


#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
#include <chrono>


std::mutex mtx;

int main() {

    {
        int shared_memory(0);
        //std::atomic<int> shared_memory(0);

        auto count_func = [&]() -> void {
            for (int i = 0; i < 1000; ++i) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));

                // mtx.lock();

                // std::lock_guard lock(mtx);
                std::scoped_lock lock(mtx);

                shared_memory++;
                // shared_memory.fetch_add(1);

                // mtx.unlock();
            }
        };

        std::thread t1 = std::thread(count_func);
        std::thread t2 = std::thread(count_func);

        t1.join();
        t2.join();

        std::cout << "After" << std::endl;
        std::cout << shared_memory << std::endl;
        

        /*
         2000이 출력되지 않는다. t1이 shared_memory를 읽어들인 사이에 t2가 shared_memory의
         값을 바꾸게 되고, 이로 인해 두개의 스레드가 각각 천번의 연산을 했음에도 최종결과는 2000이 되지 못하는 것이다.
         이 문제를 해결하기 위해 atomic을 사용한다. 다만 atomic은 속도가 느리다. mutex를 사용해도 된다.
         다만 mutex로 인해 여러 실수가 발생할 수 있기 때문에 lock_guard가 존재한다.
         C++ 17에는 scooped_lock도 존재한다.
         */

        std::cout << std::endl;

    }


    return 0;
}



```

