# 19.3 std thread와 멀티쓰레딩 기초



```C++

// main.cpp

#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <vector>
#include <mutex>


std::mutex mtx; // mutual exclusion



int main() {


    // process는 OS가 관리하며, process 내부에서 thread를 관리.
    // physical cores의 두배 정도를 logical processors로 보면 된다.
    // Cores: 8, Logical processors: 16의 OS가 Processes 159, Threads 2200인 장면을 확인.
    // process 하나가 logical processor 하나를 사용.

    {

        std::cout << std::thread::hardware_concurrency() << std::endl;  // logical processor
        std::cout << std::this_thread::get_id() << std::endl; // main 함수가 실행되고 있는 this thread
        std::cout << std::endl;

    }

    {
        const int num_pro = std::thread::hardware_concurrency();

        std::cout << std::this_thread::get_id() << std::endl;

        // main 함수가 어떤 스레드에서 작동을 한다. 그리고 그 스레드에서 다른 스레드 t1을 실행시킨다.
        // 그러면 새로 생긴 스레드는 원래 자신을 실행시킨 스레드와 상관없이 실행이 된다.
        // 스레드 t1이 종료되기 전에 main 함수의 스레드가 종료되면 문제가 생긴다. 이러한 이유로 join()이 필요하다.
        // join()을 통해 t1이 종료될 때까지 main()이 기다려 준다.

        std::thread t1 = std::thread([]() -> void {
            std::cout << std::this_thread::get_id() << std::endl;
            while (true) {}
        });

        std::thread t2 = std::thread([]() -> void {
            std::cout << std::this_thread::get_id() << std::endl;
            while (true) {}
        });

        std::thread t3 = std::thread([]() -> void {
            std::cout << std::this_thread::get_id() << std::endl;
            while (true) {}
        });

        std::thread t4 = std::thread([]() -> void {
            std::cout << std::this_thread::get_id() << std::endl;
            while (true) {}
        });

        t1.join();
        t2.join();
        t3.join();
        t4.join();

        std::cout << std::endl;
    }

    {
        const int num_pro = std::thread::hardware_concurrency();

        std::cout << std::this_thread::get_id() << std::endl;

        std::vector<std::thread> my_threads;
        my_threads.resize(num_pro);

        for (auto &e:my_threads)
            e = std::thread([]() -> void {
                std::cout << std::this_thread::get_id() << std::endl;
                while (true) {}
            });

        for (auto &e : my_threads)
            e.join();

        std::cout << std::endl;
    }

    {
        auto work_func = [](const std::string &name) -> void {
            for (int i = 0; i < 5; ++i) {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));

                mtx.lock();
                std::cout << name << " " << std::this_thread::get_id() << " is working " << i << std::endl;
                mtx.unlock();
            }
        };


//        work_func("JackJack");
//        work_func("Dash");

        std::thread t1 = std::thread(work_func, "JackJack");
        std::thread t2 = std::thread(work_func, "Dash");


        t1.join();
        t2.join();

        std::cout << std::endl;
    }


    return 0;
}



```

