# 15.3 이동 생성자와 이동 대입



```C++

// main.cpp

#include "Timer.h"
#include "Resource.h"
#include "AutoPtr.h"


AutoPtr<Resource> generateResource() {
    AutoPtr<Resource> res(new Resource(10000000));
    return res;
}


int main() {

    std::streambuf *orig_buf = std::cout.rdbuf();
    // std::cout.rdbuf(NULL);  //  disconnect cout from buffer.

    Timer timer;

    {
        // VS와 달리 CLion에서는 복사 생성자와 대입 연산자를 R-value reference를 사용해서
        // 오버로딩 해야 에러가 발생하지 않는다.
        AutoPtr<Resource> main_res;
        main_res = generateResource();
    }

    std::cout.rdbuf(orig_buf);
    timer.elapsed();


    return 0;
}



```

<br>

```C++

// Resource.h

#ifndef DEC_RESOURCE_H
#define DEC_RESOURCE_H

#include <iostream>

class Resource {

public:
    int *m_data = nullptr;
    unsigned m_length = 0;

public:
    Resource() {
        std::cout << "Resource default constructed " << std::endl;
    }

    Resource(unsigned length) {
        this->m_data = new int[length];
        this->m_length = length;
    }

    Resource(const Resource &res) {
        std::cout << "Resource copy constructed " << std::endl;

        Resource(res.m_length);

        for (unsigned i = 0; i < m_length; ++i)
            m_data[i] = res.m_data[i];
    }


    ~Resource() {
        std::cout << "Resource destroyed " << std::endl;

        if (m_data != nullptr) delete[] m_data;

    }

    Resource &operator=(Resource &res) {
        std::cout << "Resource copy assignment" << std::endl;

        if (&res == this) return *this;

        if (this->m_data != nullptr) delete[] m_data;

        m_length = res.m_length;
        m_data = new int[m_length];

        for (unsigned i = 0; i < m_length; ++i)
            m_data[i] = res.m_data[i];

        return *this;
    }

    void print() {
        for (unsigned i = 0; i < m_length; ++i)
            std::cout << m_data[i] << " ";

        std::cout << std::endl;
    }
};

#endif //DEC_RESOURCE_H

```

<br>

```C++

// AutoPtr.h

#ifndef DEC_AUTOPTR_H
#define DEC_AUTOPTR_H

#include <iostream>

// std::auto_ptr<int>;  C++ 98에서 등장, C++ 11 부터 사용하지 않기로 했고, C++ 17에서는 완전히 없애기로 함.


template<class T>

class AutoPtr {
public:
    T *m_ptr = nullptr;

public:
    AutoPtr(T *ptr = nullptr)
            : m_ptr(ptr) {
        std::cout << "AutoPtr default constructor" << std::endl;

    }

    ~AutoPtr() {

        std::cout << "AutoPtr destructor" << std::endl;
        if (m_ptr != nullptr) delete m_ptr;
    }


//    AutoPtr(AutoPtr &a) {
//        std::cout << "AutoPtr copy constructor" << std::endl;
////        m_ptr = a.m_ptr;
////        a.m_ptr = nullptr;
//
//        // deep copy
//        m_ptr = new T;
//        *m_ptr = *a.m_ptr;
//    }
//
//    AutoPtr &operator=(AutoPtr &a) {
//
//        std::cout << "AutoPtr copy assignment " << std::endl;
//
//        if (&a == this)
//            return *this;
//
////        delete m_ptr;
////        m_ptr = a.m_ptr;
////        a.m_ptr = nullptr;
////        return *this;
//
//        if (m_ptr != nullptr) delete m_ptr;
//
//        // deep copy
//        m_ptr = new T;
//        *m_ptr = *a.m_ptr;
//
//        return *this;
//
//    }



    AutoPtr(AutoPtr &&a)
            : m_ptr(a.m_ptr) {
        a.m_ptr = nullptr;   // really necessary? 권장.
        std::cout << "AutoPtr move constructor" << std::endl;
    }

    AutoPtr &operator=(AutoPtr &&a) {
        std::cout << "AutoPtr move assignment" << std::endl;
        if (&a == this)
            return *this;

        if (!m_ptr) delete m_ptr;

        // shallow copy
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;   // really necessary? 권장.

        return *this;
    }


    T &operator*() const { return *m_ptr; }

    T *operator->() const { return m_ptr; }

    bool isNull() const { return m_ptr == nullptr; }
};

#endif //DEC_AUTOPTR_H

```

<br>

```C++

// Timer.h

#ifndef DEC_TIMER_H
#define DEC_TIMER_H


#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

class Timer {

    using clock_t =std::chrono::high_resolution_clock;
    using second_t = std::chrono::duration<double, std::ratio<1>>;

    std::chrono::time_point<clock_t> start_time = clock_t::now();

public:
    void elapsed() {
        std::chrono::time_point<clock_t> end_time = clock_t::now();
        std::cout << std::chrono::duration_cast<second_t>(end_time - start_time).count() << std::endl;
    }
};


#endif //DEC_TIMER_H

```

<br>