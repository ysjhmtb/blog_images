# 15.1 이동의 의미와 스마트 포인터



```C++

// main.cpp

#include <iostream>
#include <string>
#include "Resource.h"
#include "AutoPtr.h"


// RAII : resource acquisition is initialization

void doSomething() {

    try {

        // Resource *res = new Resource;   // dull pointer
        AutoPtr<Resource> res(new Resource);   // smart pointer

        if (true) {
            throw -1;
//            delete res;
//            return;    // early return.

        }

        // delete res;

    } catch (...) {

    }


    return;
}

int main() {

    // doSomething();

    AutoPtr<Resource> res1(new Resource);
    AutoPtr<Resource> res2;

    std::cout << std::boolalpha;
    std::cout << res1.m_ptr << std::endl;
    std::cout << res2.m_ptr << std::endl;

    // 여기서 문제가 발생한다. 두 스마트 포인터가 모두 같은 곳을 포인팅하게 되는데, 향후 두번
    // 소멸자가 실행되면 문제가 발생한다.
    // 이와 같은 문제를 해결하기 위해 AutoPtr에서 복사 생성자와 = 연산자를 오버로딩한다.
    res2 = res1;    // move semantics


    std::cout << res1.m_ptr << std::endl;
    std::cout << res2.m_ptr << std::endl;


    // syntax vs. semantics
    int x = 1, y = 1;
    x + y;

    std::string str1("Hello"), str2("World");
    str1 + str2;  // append

    // value semantic (copy semantics)
    // reference semantics (pointer)
    // move semantics (move)

    


    return 0;
}



```

<br>

```C++

// Resource.h

#ifndef DEC_RESOURCE_H
#define DEC_RESOURCE_H

#include <iostream>

class Resource {

public:
    int m_data[100];

public:
    Resource() {
        std::cout << "Resource constructed " << std::endl;
    }

    ~Resource() {
        std::cout << "Resource destroyed " << std::endl;
    }
};

#endif //DEC_RESOURCE_H

```

<br>

```C++

// AutoPtr.h

#ifndef DEC_AUTOPTR_H
#define DEC_AUTOPTR_H

#include <iostream>

// std::auto_ptr<int>;  C++ 98에서 등장, C++ 11 부터 사용하지 않기로 했고, C++ 17에서는 완전히 없애기로 함.


template<class T>

class AutoPtr {
public:
    T *m_ptr = nullptr;

public:
    AutoPtr(T *ptr = nullptr)
            : m_ptr(ptr) {

    }

    ~AutoPtr() {
        if (m_ptr != nullptr) delete m_ptr;
    }


    AutoPtr(AutoPtr &a) {
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;
    }

    AutoPtr &operator=(AutoPtr &a) {
        if (&a == this)
            return *this;
        delete m_ptr;
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;
        return *this;

    }


    T &operator*() const { return *m_ptr; }

    T *operator->() const { return m_ptr; }

    bool isNull() const { return m_ptr == nullptr; }
};

#endif //DEC_AUTOPTR_H

```

<br>