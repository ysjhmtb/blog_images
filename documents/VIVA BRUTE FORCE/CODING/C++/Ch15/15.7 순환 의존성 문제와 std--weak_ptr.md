# 15.7 순환 의존성 문제와 std::weak_ptr



```C++

// main.cpp

#include <iostream>
#include <memory>
#include <string>

class Person {

    std::string m_name;
    // std::shared_ptr<Person> m_partner;
    std::weak_ptr<Person> m_partner;

public:
    Person(const std::string &name) : m_name(name) {
        std::cout << m_name << " created \n";

    }

    ~Person() {
        std::cout << m_name << " destroyed \n";
    }

    friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2) {
        if (!p1 || !p2)
            return false;

        p1->m_partner = p2;
        p2->m_partner = p1;

        std::cout << p1->m_name << " is partnered with " << p2->m_name << std::endl;
        return true;
    }

    // std::weak_ptr의 단점인데, 내용물을 사용하려면 lock()이 필요하다.
    const std::shared_ptr<Person> getPartner() const {
        return m_partner.lock();
    };

    const std::string &getName() const {
        return m_name;
    }

};


int main() {

    auto lucy = std::make_shared<Person>("Lucy");
    auto ricky = std::make_shared<Person>("Ricky");

    partnerUp(lucy, ricky); // memory leak
    // std::shared_ptr<Person> m_partner가 상대방을 포인팅 하고 있어서, 메모리 해제가 안 되는 것이다.
    // weak pointer를 사용하면 해결된다. std::weak_ptr<Person> m_partner;

    std::cout << lucy->getPartner()->getName() << std::endl;


    return 0;
}



```

<br>