# 12.9 객체 잘림과 reference wrapper





```C++

// main.cpp

#include <iostream>
#include <string>
#include <vector>
#include <functional>

using namespace std;


class Base {
public:
    int m_i = 0;

    virtual void print() {
        cout << "I'm Base" << endl;
    }
};

class Derived : public Base {
public:
    int m_j = 1;

    virtual void print() override {
        cout << "I'm derived" << endl;
    }
};

void doSomething(Base &b) {
    b.print();
}


int main() {

    Derived d;
    Base b = d; // & 가 없는 상태.

    b.print();  // I'm Base


    // vector에는 reference &를 넣을 수 없다.
    std::vector<Base> my_vec;
    my_vec.push_back(b);
    my_vec.push_back(d);

//    I'm Base
//    I'm Base
    for (auto &ele:my_vec)
        ele.print();


    // vector에 reference를 사용하려면.
    std::vector<std::reference_wrapper<Base>> my_vec2;
    my_vec2.push_back(b);
    my_vec2.push_back(d);

//    I'm Base
//    I'm derived
    for (auto &ele:my_vec2)
        ele.get().print();  // get() 필요!


    return 0;
}

```

