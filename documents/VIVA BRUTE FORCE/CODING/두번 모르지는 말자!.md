# 두번 모르지는 말자!

 지금 재직 중인 회사에 입사하기 전 다음처럼 전화면접이 있었다.

<br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/A****.png">

<br>

 아쉽게도 면접에서 너무나 부족한 답변을 했고, 당연히 탈락하였다. 탈락은 아쉽지만 그와 별개로 그 당시에 몰랐던 내용을 적어도 또 몰라서는 안 되는만큼 그때 답변하지 못했던 것중 하나를 오늘 상기해 보았다.

<br>

 당시 제대로 답변하지 못했던 내용 중 하나가 프로세스와 쓰레드를 메모리와 연결해서 설명하지 못했던 부분이다.

<br>

 이에 대해 잘 정리된 다음의 글을 발견하였다.

[[OS]메모리 관점에서 본 프로세스(Process)](https://mooneegee.blogspot.com/2015/01/os-process.html)

[[OS]메모리 관점에서 본 쓰레드(thread)](https://mooneegee.blogspot.com/2015/01/os-thread.html)

그리고 다음의 그림이 직관적인 이해를 가능하게 해주었다.

<br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/processVSthread.png">

<br>

Process는 OS에 의해 실행 중인 프로그램이다. 그리고 이 프로세스가 실행되기 위해서는 위의 이미지에서 볼 수 있는 다음의 메모리 공간이 필요하다.

<br>

stack : 지역변수, 매개변수, 리턴 값 등이 저장. 함수 호출 시에 생성되고, 함수가 종료되면 반환. 컴파일 시에 크기가 결정된다. <br>

heap : 동적 할당을 위한 공간. 런타임 시에 크기가 결정된다. <br>

data : 전역변수나 static 변수 등이 저장. 프로그램 종료시까지 적재. <br>

code : 작성한 소스코드가 존재하는 공간. 상수와 컴파일 된 기계어가 존재. 프로그램 종료시까지 적재. <br>

<br>

그림에서 볼 수 있는 것처럼 각각의 프로세스는 메모리 공간에서 독립적으로 존재한다. 3개의 프로세스가 존재한다면 각각의 프로세스는 같은 구조의 메모리 공간을 가진다. pipe 같은 IPC(Inter Process Communication)가 아니면 다른 프로세스의 메모리 공간에 접근하는 것은 불가능하다.

<br>

Thread는 하나의 프로세스에 존재하는 여러 개의 실행 흐름인데, 프로세스와 달리 쓰레드는 stack을 제외한 메모리 영역을 공유한다. 따라서 쓰레드는 프로세스에 비해 컨텍스트 스위칭 때문에 발생하는 overhead가 작다.