[순열(permutation) 알고리즘 구현 - 상상개발자](https://www.youtube.com/watch?v=edlDaLrfVbA)와 [minsuk-heo/problemsolving](https://github.com/minsuk-heo/problemsolving/blob/master/dynamic_programming/permutation.py)을 통해서 순열 알고리즘에 대해 배우게 되었다.

A,B,C라는 문자열이 주어졌을 때, 중복되지 않으면서 나열 가능한 경우는 어떻게 알 수 있을까?

교환과 재귀를 통해 구할 수 있으면 다음과 같이 이해했다.



> 첫번째 인덱스에서 교환 가능한 경우를 생각해 보면
>
> **A** B C	: 이 경우는 첫번째 인덱스와 첫번째 인덱스 자신과의 교환
>
> B **A** C
>
> C B **A**
>
> 이 가능함을 알 수 있다.



> 두번째 인덱스에서는 
>
> A **B** C	: 이 경우는 두번째 인덱스와 두번째 인덱스 자신과의 교환
>
> A C **B** 
>
> B **A** C	: 두번째 인덱스와 두번째 인덱스 자신과의 교환
>
> B C **A** 
>
> C **B** A	: 두번째 인덱스와 두번째 인덱스 자신과의 교환
>
> C A **B**  



> 세번째 인덱스에서는 자기 자신과의 교환만이 존재한다.



따라서 다음과 같은 경우의 수를 생각할 수 있다.

```python
['A', 'B', 'C']
['A', 'C', 'B']
['B', 'A', 'C']
['B', 'C', 'A']
['C', 'B', 'A']
['C', 'A', 'B']
```



https://github.com/minsuk-heo/problemsolving/blob/master/dynamic_programming/permutation.py 에 존재하는 코드는 다음과 같다.

```python
# https://github.com/minsuk-heo/problemsolving/blob/master/dynamic_programming/permutation.py

# [A B C], 0
def perm(n, i):
    if i == len(n) - 1:
        print(n)
    else:
        # j = 0 ~ 2
        for j in range(i, len(n)):
            # n[0], n[1] = n[1], n[0] --> B A C
            n[i], n[j] = n[j], n[i]
            # perm([B A C], 1)
            perm(n, i + 1)
            # n[0], n[1] = n[1], n[0] --> A B C
            # C B A를 위한 복원
            n[i], n[j] = n[j], n[i]  # swap back, for the next loop


perm(['A', 'B', 'C'], 0)
```



코드가 동작하는 과정을 살펴보면



> **perm(['A','B','C'], 0)** 
>
> i = 0, j = 0	1) n[i], n[j] = n[j], n[i] 를 통해 첫번째 인덱스와 첫번째 인덱스 교환
>
> ​			2) perm(n, i + 1) 실행.
>
> ​			   **perm(['A','B','C'], 1)**  	
>
> ​			    i = 1, j = 1	1) n[i], n[j] = n[j], n[i] 를 통해 두번째 인덱스와 두번째 인덱스 교환
>
> ​						2)  perm(n, i + 1) 실행.
>
> ​						   **perm(['A','B','C'], 2)** 
>
> ​						    i = 2 	1)  print(n)  실행
>
> ​								      A B C
>
> ​			3) 첫번째 인덱스와 두번째 인덱스의 교환에 앞서
>
> ​			    1)에서 진행했던 첫번째 인덱스와 첫번째 인덱스의 교환을 원상복구.
>
> ​			    n[i], n[j] = n[j], n[i]

과 같이 진행됨을 알 수 있다.



함수의 호출이 변화하는 과정을 관찰하면 다음과 같다.

> **perm(A B C, 0)**
>
> perm(A B C, 1)
>
> perm(A B C, 2) 
>
> perm(A C B, 2)
>
> **perm(B A C, 1)**
>
> **perm(B A C, 2)**
>
> perm(B C A, 2)
>
> perm(C B A, 1)
>
> perm(C B A, 2)
>
> perm(C A B, 2) 



다음은 학습한 내용을 내가 자바 코드로 구현해 본 것이다.

```java
public class Permutation {
    public static void main(String[] args) {
        Permutation ref = new Permutation();
        String[] str = new String[]{"A", "B", "C"};
        ref.makePermutation(str, 0);

    }

    public void makePermutation(String[] str, int i) {
        if (i == str.length - 1) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j <= i; j++) {
                sb.append(str[j]);
            }
            System.out.println(sb.toString());
        } else {
            for (int j = i; j < str.length; j++) {
                String temp = str[i];
                str[i] = str[j];
                str[j] = temp;

                makePermutation(str, i + 1);

                temp = str[i];
                str[i] = str[j];
                str[j] = temp;
            }
        }
    }
}

```

