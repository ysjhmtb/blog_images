<br><br>

> YKH : ex) HDMI >> terminology >> code git 

<br><br>

> grep Tuner
>
> 
>
> 안드로이드 스튜디오에서의 NDK 빌드 환경
>
> Java에서 C/C++ 호출
>
> C/C++에서 Java 호출
>
>
> RTC DS1302

<br><br>

[리눅스(samba)서버에 윈도우 PC [네트워크 드라이브 연결] 하기](https://seeds.tistory.com/632)

<br><br>

[How to take a picture of a black hole](https://www.ted.com/talks/katie_bouman_what_does_a_black_hole_look_like)

<br><br>

> [This is Dr Katie Bouman the computer scientist behind the first ever image of a black-hole. She developed the algorithm that turned telescopic data into the historic photo we see today.](https://www.reddit.com/r/pics/comments/bbql1i/this_is_dr_katie_bouman_the_computer_scientist/)
>
> <img src="https://preview.redd.it/shhy0jzoshr21.jpg?width=960&crop=smart&auto=webp&s=3963a1935e7498d031d31c96736054bb68ec6203">

<br><br>

> 공부를 한다는 일은 좋은 설명을 찾는 과정이다. 어떤 내용이 이해가 안가거든 이유는 항상 둘 중 하나다. 1) 내가 이걸 이해하는데 필요한 사전 공부가 안돼있다. 2) 나에게 설명을 해주는 사람도 사실은 이해를 못하고 있다. 1번이 아니라면 2번의 경우라고 보면 된다.
>
> [오후 8:28 - 2019년 4월 5일](https://twitter.com/daesanhwang/status/1114369301039869953)

<br><br>

> 나는 좋은 개발자가 되기 위한 가장 중요한 요소가 "의지" 혹은 "끈기" 라고 생각한다. 이해가 안돼도 계속 이해하려는 시도를 하는 것, 해결하기 어려운 문제가 있을 때 계속 부딪혀보는 것. 버거워 포기하면 당연히 성장이 없는 답보상태에 머무르게 된다.
>
> [오후 7:16 - 2019년 4월 1일](https://twitter.com/HyunSeob_/status/1112901713583779840)

<br><br>

> 개발로 8-9년 먹고 살면서 철학이 몇가지 생겼다. 컴퓨터 기술에 어려운건 없다. 단지 아느냐 모르냐만 있을 뿐이다. 응용력은 반복적 학습과 활용을 기초로 나온다. 내가 모르는게 뭔지를 파악하는게 실력이다. 내가 신기술을 익히는 속도보다 신기술은 언제나 빠르게 발전한다
>
> [오후 7:09 - 2019년 3월 25일](https://twitter.com/SongAndSook/status/1110363194227195905)
>
> 무엇이든 나누고 정리해서 하나씩 처리하는것이 정도이다. 요행은 운이고 운은 항상 함께하지 않는다. 내눈으로 확인하지 못한것을 확신하지 말라. 나와 다른 결과를 다른사람의 경험으로 제시하면 나부터 의심하라. 컴퓨터는 거짓말을 하지 않는다.
>
> [오후 7:13 - 2019년 3월 25일](https://twitter.com/SongAndSook/status/1110364171424522240)

<br><br>

> At both Viaweb and YC, every minute I spent thinking about competitors was, in retrospect, a minute wasted.
>
> [오후 3:30 - 2019년 3월 22일](https://twitter.com/paulg/status/1109220781035307009)

<br><br>

[What are good resources for learning STM microcontrollers?](https://www.quora.com/What-are-good-resources-for-learning-STM-microcontrollers)

<br><br>

[Bluetooth low energy Services, a beginner's tutorial](https://devzone.nordicsemi.com/tutorials/b/bluetooth-low-energy/posts/ble-services-a-beginners-tutorial)

<br><br>

> [Getting started for beginners](https://devzone.nordicsemi.com/f/nordic-q-a/30338/getting-started-for-beginners)
>
> [Martin Lesund ](https://devzone.nordicsemi.com/members/male)
>
> Hello Dominik,
>
>   If you are a total beginner I would highly recommend you to get the [nRF52 DK](https://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF52-DK) *"which provides our nRF52832 chip with all the I/O and interfaces via connectors and has 4 LEDs and 4 buttons which are user-programmable".* It also includes an on-board debugger/programmer which mean that you can plug it directly to your computer via a µUSB cable, and start developing and testing right away.  This makes it very user friendly and easy to test out the different functionality and features of our nRF52832 chip.
>
>   We also provide the "[Software Development Kit](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk%2Fdita%2Fsdk%2Fsdk.html&cp=4)s" (SDK) which is the environment you will develop your application with. It provides the all the drivers, libraries, lots of already made[ example](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v14.2.0%2Fexamples.html&cp=4_0_0_4)s to make development more convenient. You will know what I mean when you start programming. *(note: we have examples in the SDK for how to use the TWI, GPIO,UART...)*
>
> 
>
>  Please take your time and look at these different links which should provide the necessary information to get you started:
>
> - [nRF5 Getting Started](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.gs%2Fdita%2Fgs%2Fgs.html&cp=1)
>
> *This link includes an overview of **Development Kits**, **Product Specification, Available Protocols, Nordic tools and Downloads, Software Development** etc.*
>
> - [Getting Started with the SDK and running examples](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v14.2.0%2Fnrf51_getting_started.html&cp=4_0_0_1)
>
> *This link will show you how to get started with **Installing the SDK, Compiling/running your first example** etc.*
>
> - [Getting Started with SEGGER Embedded Studio IDE](https://www.youtube.com/watch?v=YZouRE_Ol8g&list=PLx_tBuQ_KSqGHmzdEL2GWEOeix-S5rgTV) 
>
> *This link shows a video tutorial series how to use "SES" to program, compile, flash application to your device.*
>
> - [Tutorial Page ](https://devzone.nordicsemi.com/tutorials/) ( [Getting started](https://devzone.nordicsemi.com/tutorials/b/getting-started),  [BLE](https://devzone.nordicsemi.com/tutorials/b/bluetooth-low-energy), [SDK](https://devzone.nordicsemi.com/tutorials/b/software-development-kit), [Hardware and Layout](https://devzone.nordicsemi.com/tutorials/b/hardware-and-layout), [Design Example](https://devzone.nordicsemi.com/tutorials/b/design-examples))
>
> *This link is for general tutorials (step-by-step guides)* 
>
> 
>
> **UPDATE 17.07.18**
>
> **- Getting Started Guide SEGGER**
>
> **- Getting Started Guide ARM Keil**
>
> 
>
>  Best Regards,
>
> 
>
>   Martin L.

<br><br>

[What does device tree mean in Android?](https://www.quora.com/What-does-device-tree-mean-in-Android/answer/Vijay-Jaiswal-79)

<br><br>

[How I'm able to take notes in mathematics lectures using LaTeX and Vim](https://castel.dev/post/lecture-notes-1/)

<br><br>

[nRF52 Development Kit (for nRF52832)](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.nrf52%2Fdita%2Fnrf52%2Fdevelopment%2Fnrf52_dev_kit.html)

<br><br>

[Unix History Repository](https://github.com/dspinellis/unix-history-repo)

<br><br>

[Apache Reverse Proxy 구성 예제](https://jinhokwon.tistory.com/121)

[How To Configure Apache Virtual Hosts In Ubuntu 18.04 LTS](https://www.ostechnix.com/configure-apache-virtual-hosts-ubuntu-part-1/)

<br><br>

[x86 Bare Metal Examples](https://github.com/cirosantilli/x86-bare-metal-examples)

<br><br>

[VirtualBox, 자유롭게 화면 해상도 조절하기.](https://technote.kr/157)

<br><br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/%EA%B0%80%EC%9E%A5%20%EC%A4%91%EC%9A%94%ED%95%9C%20%EC%A3%BC%ED%8A%B9%EA%B8%B0.JPG">

<br><br>

> 확률과 통계 문제 만큼 컴퓨터로 실험하기 좋은, 흥미로운 주제도 흔치 않다. 개인적으로 가장 존경하는 과학자가 실험 과학자로 유명했던 마이클 패러데이 이기도 하고, 아인슈타인도 패러데이를 존경해 침실 벽면에 그의 초상화를 붙여두었다고 한다.
>
> 컴퓨터를 통한 최초의 수학 증명은 1976년 4색 정리였다. 당시만 해도 고작 1,936개의 모델을 계산하는데 두 대의 컴퓨터로 50일이 넘게 걸렸다. 뿐만 아니라 수학적으로 우아하지 못하다는 비판이 잇따랐지만 역사적으로 볼때 공학적 기술은 언제나 이론을 앞서갔다.
>
> [사다리 게임, 절대 걸리지 않는 법](http://docs.likejazz.com/ghost-leg-probabilities/)

<br><br>

> 바쁠수록 하루에 두가지씩만 끝내자. 오늘의 투두 리스트는 1) 위치정보 관련 앱 크래시 버그 수정 2) 자바스크립트 => 루비 트랜스파일러 구현
>
> [오후 6:42 - 2019년 3월 12일](https://twitter.com/daesanhwang/status/1105645271545868288)

<br><br>

[Usability improvements in GCC 9](https://developers.redhat.com/blog/2019/03/08/usability-improvements-in-gcc-9/)

<br><br>

> 요즘 연구하고 있는 문제가 물건을 손으로 밀었을때 위치를 추정하는 문제입니다. 제어된 환경에서 최대한 정확하게 측정된 자료를 가지고도 미래의 위치를 예측하는 것은 매우 어렵습니다. 반면 미래를 예측한다는 사람은 곳곳에 넘쳐 납니다.
>
> [오후 12:06 - 2019년 3월 5일](https://twitter.com/JongraeK/status/1103023967701475329)

<br><br>

> [초등학교 덧셈 알고리즘을 코드로 써보기](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/)
>
> <br>
>
> **일러두기**
>
> - 이 글은 순전히 저의 개인적인 의견이며 전/현직 회사와는 무관합니다.
> - 소개된 문제는 [인터넷에서 찾을 수 있는 문제](https://leetcode.com/problems/add-strings/)이며 실제 면접에선 변형된 문제를 냈음을 밝힙니다.
> - 미국 회사에서 겪은 경험에 기반해 쓴 글이므로 한국 상황과는 다를 수 있습니다.
>
> **3줄 요약**
>
> - 코딩 면접에서 문제 해결 능력과 코딩 능력은 다릅니다.
> - 의외로 사소해 보이는 부분에서도 코딩 능력을 꽤 많이 가늠할 수 있습니다.
> - 코딩 면접 준비 시 ~~다이나믹 프로그래밍에 시간 허비하지 말고~~ 기초 코딩 능력을 한번 더 점검할 것을 추천합니다.
>
> ------
>
> 개발자, 영어로 SWE(Software Engineer)[1](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fn:SWE) 또는 SDE(Software Development Engineer)로 대표되는 직업군에 있어 코딩 인터뷰는 필수다. 굳이 이 글에서 코딩 인터뷰가 유용성까지 말하기는 벅차다. 그냥 한 문제를 예로 들면서 코딩 인터뷰의 주요 평가 요소와 실제 지원자들이 어떻게 코딩하는지 이야기를 해볼까 한다. 결국 기본적인 코딩 능력이 중요하다.
>
> ## 코딩 인터뷰의 평가 요소
>
> 코딩 인터뷰를 통과하려면 당연히 ‘코딩’을 잘해야 하는데 이 말은 다소 모호하다. 어떤 평가 요소가 있는지 먼저 살펴봐야 한다. 가장 중요한 요소는 “문제 해결 능력”과 “코딩 능력”이다. 이 둘은 언뜻 비슷해 보이지만 확연히 구분된다. 면접관은 이 두 주요 능력에 대한 긍정적 및 부정적 신호를 코딩 면접에서 최대한 많이 찾아낸 뒤 최종적으로 당락을 결정한다.
>
> ### · 문제 해결 능력
>
> 먼저, 문제 해결 능력이란, 예를 들어, “주어진 배열에서 중복된 요소를 제거하세요” 같은 문제가 있다면, 이것에 대한 해법을 논리적으로 설명할 수 있는 능력이다. 적절하고 효율적인 자료구조를 고르고, 알고리즘을 고안해내 면접관에게 설명해야 한다. 기초적인 자료구조와 알고리즘 지식, 전산학 기초 지식, 문제 해결에 대한 창의력 등을 평가할 수 있다. 이 과정에서 코딩이 필요한 것은 아니다.
>
> 여기서 코딩 인터뷰에서 문제를 받았을 때 바로 코딩을 시작하는 것이 좋지 않음을 알 수 있다. 아무리 쉬운 문제라도 먼저 면접관에게 접근 방법을 명확하게 설명하는 것이 좋다. 그렇다고 해서 모든 경우를 완벽하게 코딩 전에 설명하라는 것은 아니다. 코드로 옮기다 보면 미처 생각하지 못한 예외 사항을 뒤늦게 발견할 수 있을 것이다. 괜찮다. 하지만 대략적인 접근법은 코딩에 앞서 설명을 해야 한다.
>
> ### · 코딩 능력
>
> 코딩 능력은 이제 제안한 알고리즘을 특정 프로그래밍 언어로 옮겨 쓸 수 있는 능력이다. 문제 해결 능력과는 분명히 다른 요소이다. 매우 기본 코딩 능력인 변수, 조건문, 반복문부터 함수/메서드의 작성 등 말 그대로 코드를 쓰는 과정에서 지원자의 코딩 경험 및 실력을 가늠할 수 있다.
>
> 내 경험에 따르면 금융 회사들은 프로그래밍 언어 지식에 대해서도 깊게 평가한다. 하지만 특정 언어 지식 자체는 대게 평가 요소는 아니다. 그래도 시니어급 지원자가 주력 언어의 기본적인 작업, 숫자를 문자열로 바꾸는 방법 같은 것을 잘 모른다면 적어도 나에게는 나쁜 신호이다. 코딩 스타일도 그러하다. 사소한 스타일에서도 몇몇 신호를 찾을 수 있다.
>
> 마지막으로 소통 능력, 논리적으로 자기 생각을 얼마나 잘 조리 있게 말하는 가도 중요한 요소이며, 코드를 꼼꼼하게 검증하는 능력도 소홀히 해서는 안 된다.
>
> ## 좋은 코딩 문제란?
>
> 참 어려운 질문이다. 코딩 인터뷰 준비로 널리 알려진 릿코드에 가보면 이미 [천 개의 문제](https://leetcode.com/problemset/all/)가 있다.[2](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fn:LC) 좋은 문제도, 이상한 문제도, 나쁜 문제도 있다. 면접관의 철학과 취향에 따라, 또는 회사의 방침에 코딩 문제의 유형이 달라질 수도 있다.
>
> 내 생각에 좋은 코딩 문제는 ‘적절한’ 문제 해결 능력과 ‘적절한’ 코딩 능력을 모두 볼 수 있는 문제가 좋다. 적절한이란 단어가 좀 애매하다. 그래서 10명 이상 지원자에게 이 문제를 줬을 때 ‘적절한’ [정규분포](https://en.wikipedia.org/wiki/The_Bell_Curve)가 나오는 문제를 좋은 문제라고 생각한다. 중간 난이도의 문제라면 평균적으로 푸는 사람이 가장 많아야 하며, 못 푸는 사람과 잘 푸는 사람이 비슷한 빈도로 나오면 좋다. 특별히 쉽거나 어려운 문제는 어느 정도 편향이 발생할 것이고 이건 괜찮다.
>
> 말이 쉽지 여전히 아리송하다. 한 예로 설명해보자. 나는 다이나믹 프로그래밍 문제를 싫어한다. 면접 문제로 적합하지 않다. 문제 해결이 지나치게 어렵기 때문이다. 미리 열심히 공부하지 않으면 아예 건드리기도 힘들 수 있다. 알더라도 점화식(recurrence)을 찾는 건 굉장한 논리적 도약이 필요하다. 이런 문제는 종형 분포가 나오지 않고 잘 풀거나 아예 못 풀거나로 나뉘어 버린다. 한마디로 A+, A0, D, F 학점만 나오는 일이 벌어진다.
>
> 더욱 큰 문제는 문제 해결은 어려운데 코딩은 매우 단순하다는 것이다. 다이나믹 프로그래밍 문제는 보통 테이블에 값만 잘 설정하면 끝나므로 코딩 능력을 깊게 살펴보기 어렵다. 결국 코딩 문제가 아니라 브레인 티저 문제가 되기 쉽다. 이런 이유로 페이스북과 우버 같은 회사에서는 다이나믹 프로그래밍 문제를 내지 않도록 면접관에게 권고한다.
>
> 물론 운이 정말 없다면 다이나믹 프로그래밍 문제를 내는 면접관을 만날 수 있다. 코딩 면접에서 운은 사실 굉장히 중요하다. 이럴 때도 겁내지 말고 브루트 포스로 먼저 풀고 메모이제이션 같은 걸로 최적화해도 된다.
>
> 다이나믹 프로그래밍으로 태깅된 릿코드 문제는 [130개 넘게 있으며](https://leetcode.com/tag/dynamic-programming/), 미국 소프트웨어 개발자들이 꽤 모이는 [블라인드 익명 앱](https://www.teamblind.com/search/dynamic%20programming)에서도 이 문제에 대한 한탄과 고뇌는 흔히 볼 수 있는 주제이다. 여전히 많은 코딩 면접 준비자들이 이걸로 고생하는데 참으로 안타까운 일이다. 나는 과감히 포기할 것을 ~~책임을 지지는 않지만~~ 추천한다. 차라리 다른 기본을 충실히 하는 게 훨씬 좋을 수 있다.
>
> ![img](http://minjang.github.io/assets/2019/dp.JPG)*모 회사의 어떤 회의실 이름*
>
> ------
>
> ## 오늘의 문제: 문자열로 주어진 두 숫자를 더해보세요.
>
> 서론이 너무 길었다. 드디어 제목과 관련 있는 이야기를 해보자. 오늘의 문제는 다이나믹 프로그래밍과 비교한다면 반대편에 있는 문제이다. 즉, 문제 해결 능력은 거의 없거나 간단한 수준이고 대신 코딩을 중점적으로 볼 수 있는 문제이다.
>
> 이 문제는 [릿코드에도 있으며](https://leetcode.com/problems/add-strings/) 43%가 통과한 easy 등급이다.
>
> > Given two non-negative integers `num1` and `num2` represented as string, return the sum of `num1` and `num2`.
> >
> > “문자열로 표현된 두 음이 아닌 정수 `num1`과 `num2`가 있을 때, 이 둘의 합을 반환하시오.
>
> 내 생각에 이 정도는 실력 있는 개발자에겐 쉬울 것이다. 스크리닝 인터뷰나 코딩 능력이 다소 부족할 것 같은 면접자에게 변형된 문제를 종종 낸다. 정식 코딩 인터뷰라면 이 문제는 워밍업 문제로 10-15분 내에 풀면 좋다. 그런데 쉽게 생각한 문제에서 생각보다 많은 코딩 능력 신호를 읽어낼 수 있었다. 놀랍기도 하고 한편으론 충격도 받았다. 20-30분씩 걸려서 푸는 사람들도 있었고, 끝내 제대로 완성 못한 지원자도 있었다. 물론 10분 이내에 푸는 사람도 있다.
>
> 이 문제에서 문제 해결 능력은 사실상 필요하지 않다. 그렇다. 정말 초등학교 덧셈을 하라는 이야기다. 숫자를 뒤에서 하나씩 읽어 두 합을 구한 뒤 자리 올림수(carry)를 넘겨주는 매우 매우 기본적인 덧셈 이야기다 ([그림 출처](https://blog.naver.com/snoogy1/220493885819%22)). 컴퓨터 구조에 나오는 ALU 기본 원리와 같긴 하지만 이 문제는 그렇게 심오한 게 아니다.[3](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fn:ap)
>
> ![img](http://minjang.github.io/assets/2019/addition.png)
>
> 그런데 문제를 이렇게만 주면 의외로 문자열 숫자를 그냥 정수형으로 바로 바꿔서 풀려는 사람이 있다!
>
> ```
> def add_strings(a, b):
>     return str(int(a) + int(b))
> ```
>
> 처음 겪었을 땐 깜짝 놀랐다. 솔직히 말해 코딩 인터뷰의 대부분은 문제를 위한 문제다. 그렇다면 이렇게 간단한 문제를 낼 리는 없지 않은가? 충분히 코딩 인터뷰 연습을 했다면 이런 건 시도조차 하지 않을 것이다. 그런데 이런 시도를 하는 사람이 종종 나온다. 그래서 제약 조건을 말한다. 릿코드 문제에도 이렇게 있다.
>
> > You **must not** use any built-in BigInteger library or convert the inputs to integer directly.
> >
> > “BigInteger 라이브러리 또는 전체 숫자열을 바로 정수로 변환하는 내장 기능 쓰지 마세요.”
>
> ## 코딩하기
>
> 문제 이해가 끝났으니 초등학생이 하는 그 덧셈 알고리즘을 그대로 코드로 옮기자. 차근차근 정리하면 다음과 같다:
>
> - 두 숫자 문자열을 뒤에서 각각 하나씩 읽는다. (입력은 음이 아닌 정수로 가정했으므로 예외 검사는 하지 않아도 된다.)
> - 이 두 문자를 숫자로 변환한 뒤에 (‘1’을 1로 변환하는 건 당연히 허용된다) 덧셈을 한다. 올림수를 같이 처리한다.
> - 덧셈 결과를 최종 변수에 저장하고, 올림수를 갱신한다.
> - 이 과정을 반복한다.
> - 반복문이 끝났을 때 여전히 올림수가 있는지 본다. 있으면 1을 추가한다.
>
> 여기서 까다로운 부분은 두 숫자 문자열의 길이가 다를 때이다. 상당히 재밌는 것은 이 문제를 푸는 사람마다 이 부분을 모두 제각각의 방법으로 푼다는 점이다. 여기서 여러 코딩 실력을 읽을 수 있다. 사소하다고 생각할 수도 있는데, 변수, 조건문, 반복문을 어떻게 쓰는가는 상당히 중요한 신호이다. 대부분의 코딩은 변수, 반복문, 분기문으로 이뤄진다. 이 문제에서 이런 기본기를 잘 살펴볼 수 있다.
>
> ### · 파이썬으로 풀기
>
> 요즘 인턴, 졸업 예정자, 특히 머신러닝 소프트웨어 엔지니어 지원자들은 대부분 파이썬을 코딩 면접에서 쓴다. 파이썬으로 먼저 생각해보자.
>
> - 두 입력 문자열의 길이가 다른 경우를 처리하는 것이 결국 핵심이다. 정말 다양한 방법이 있는데 나는 왠지 파이선의 `zip`이 참 맘에 든다. 이 녀석으로 두 입력 문자열에서 문자 두 개를 동시에 읽고 싶다. 그러려면 두 문자열 길이를 맞춰야 한다. 짧은 숫자 앞에다 0을 채워준다. 간단한 작업 같지만, 코딩이 부족한 사람은 여기서부터 여지없이 막힌다.
> - `zip`으로 문자 두 개를 한꺼번에 읽는 반복문을 작성한다. 거꾸로 읽어야 하는데 파이썬 문자열을 뒤집는 건 슬라이스 연산자 `[::-1]`로 하는 게 [좋아 보인다](https://stackoverflow.com/questions/931092/reverse-a-string-in-python). 우아하게 `x`, `y`를 동시에 읽은 뒤에 덧셈한다. `int`를 써도 되고 아니면 아스키 코드로 생각해서 `ord`를 써도 괜찮을 것이다.
> - 여기서 올림수, `carry`를 더해야 한다. 이 변수는 미리 0으로 초기회를 해야 한다. 놀라지 마시라. 이 부분 힘들어하는 면접자들이 꽤 있다. 문제 해결 능력이 부족하지는 않을 것이다. 하지만 `carry`를 0으로 미리 잡지 않고 허둥대는 사람들도 있다. 코딩 경험이 부족하면 벌어질 수 있는 일.
> - 덧셈한 결과가 예를 들어 14라고 하자. 당연히 4만 결과 변수에 저장을 해야 하고 1을 carry로 옮겨야 한다. 자, 여기서도 다양한 코딩을 볼 수 있었다. 분기문을 써서 하던, 나눗셈을 써서 하던 뭐가 됐던 하면 된다. 그런데 모듈로 연산자를 바로 쓰지 못하는 사람도 있다. 12년 전, 굉장한 화제가 되었던 [FizzBuzz 문제가 떠오른다](https://blog.codinghorror.com/why-cant-programmers-program/).
> - 결과를 저장할 때 뒤에다 붙일까(append) 아니면 앞에다 붙일까(prepend)? 그렇다, 여기서도 고민하고 실수하는 사람들이 있다.
>
> 보다시피 코드로 옮기는 과정이 생각보다는 조금 까다롭다. 무엇보다 구현의 자유도가 높다. 그러니 다양한 코딩 패턴을 볼 수 있고, 기초 코딩 실력을 파악할 수 있다.
>
> [대략 이 과정을 코드로 쓰면 다음과 같다](https://repl.it/repls/VisibleBisqueServer). (참고로 저는 파이썬 전문가가 아니니 제가 쓴 코드가 꼭 좋다는 보장은 없습니다.)
>
> ```
> def add_strings(a, b):
>     if len(a) > len(b):
>         b = '0' * (len(a) - len(b)) + b
>     else:
>         a = '0' * (len(b) - len(a)) + a
>     result = ""
>     carry = 0
>     for x, y in zip(a[::-1], b[::-1]):
>         sum = ord(x) + ord(y) - ord('0')*2 + carry
>         result = str(sum % 10) + result
>         carry = sum // 10
>     if carry:
>         result = '1' + result
>     return result
> 
> print(add_strings("12345", "987654321") == "987666666")
> ```
>
> 코딩을 많이 해보지 않은 분들은 길이가 다른 경우 처리를 상당히 힘들어한다. 최악의 코드는 아마도 어느 한쪽이 크다고 가정하고 쓴 코드를 통째로 복사해서 붙여넣는 것이다. 이렇게 하는 분들도 봤다. 파이썬은 언어 특성상 인덱스를 변수로 하는 루프가 흔하지 않다. 그래서 두 문자열에서 동시에 문자를 읽는 것을 척척하지 못하는 면접자들도 간혹 있다.
>
> ### · C++로 풀기
>
> 아무래도 나의 주력 언어가 C++이라서 이걸로도 풀어보자. C++ 코딩 실력을 가늠하는데도 이 문제는 꽤 유용하다. C++은 성능과 관련된 고려가 많다. 코딩 면접 시 코드를 쓰면서도 계속 내가 왜 이 방법을 택하게 되었는지 그 이유를 설명하면 좋다. 짧은 순간마다 자신의 프로그래밍 언어 지식을 말할 수 있다. 파이썬, 자바 등 다른 언어도 마찬가지다.
>
> C++로는 거꾸로 읽는 `rbegin()`을 이용해면 괜찮을 것이다. 0으로 채우는 번거로운 과정은 피하자. 추가적인 메모리 연산을 굳이 할 필요 없다. 한 쪽이 이미 끝에 다다랐을 때는 0을 주면 된다. 그리고 그냥 C++ 좀 쓴다는 티를 내고 싶어서 `stringstream`과 `reverse`를 써보았다. [코드는 이렇다](https://repl.it/repls/ImperfectSuperbOpengroup).
>
> ```
> string addStrings(string a, string b) {
>   std::stringstream ss;
>   auto i = a.rbegin();
>   auto j = b.rbegin();
>   int carry = 0;
>   while (i != a.rend() || j != b.rend()) {
>     const int x = (i == a.rend()) ? 0 : (*i++ - '0');
>     const int y = (j == b.rend()) ? 0 : (*j++ - '0');
>     const int s = x + y + carry;
>     ss << (s % 10);
>     carry = s / 10;
>   }
>   if (carry != 0) {
>     ss << 1;
>   }
>   std::string ret = ss.str();
>   std::reverse(ret.begin(), ret.end());
>   return ret;
> }
> ```
>
> 생각만큼 `rbegin()`을 능숙히 쓰는 사람이 많지는 않다. 그렇다면 인덱스 `i`, `j`를 이용하자. 여기서 사소해 보이지만 결코 사소하지 않는 이슈가 있다.
>
> 대부분 면접자는 `std::string`을 포함한 STL 자료구조의 크기나 인덱스를 `int`로 받는다. 코딩 인터뷰에서는 별문제는 없다. 하지만 STL 자료구조에서 32비트 범위가 넘는 원소 개수를 다뤄보면 `int` 인덱스가 상당히 눈에 거슬린다. STL은 안타깝게도 `unsigned` 타입의 `size_t`를 반환한다. 사실상 서버/데스크탑 컴퓨터는 모두 64비트이므로 64비트 부호 없는 정수가 된다. 다시 말하지만, 인터뷰에서는 그냥 `int` 써도 충분하다. 그런데 C++ 실력을 더욱 뽐내려면 `size_t`로 처리하는 것도 좋다.
>
> 다만 주의할 것은 `size_t`로 인덱스를 거꾸로 돌릴 때이다. -1이 되는 순간 무한 루프에 빠지기 때문이다. 그래서 나는 `[0, size)` 구간에서 반복하되 쓰는 시점에서 인덱스의 역을 구해 쓴다. -1로 종료 조건을 따져야 하는 경우를 원천적으로 피한다.
>
> ```
>   ...
>   size_t i = 0;
>   size_t j = 0;
>   while (i < a.size() || j < b.size()) {
>     int s = carry;
>     if (i < a.size()) {
>       s += (a[a.size() - 1 - i++] - '0');
>     }
>     if (j < b.size()) {
>       s += (b[b.size() - 1 - j++] - '0');
>     }
>   ...
> ```
>
> 혹시나 수식에 포함된 `i++`가 눈에 거슬릴 수 있다. 아무 생각 없이 쓰다간 [undefined behavior](https://stackoverflow.com/questions/949433/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior)를 만날 수 있다.
>
> ------
>
> ## 결론
>
> 이전 회사와 지금 회사에서 대략 100번에 가까운 코딩 인터뷰를 한 것 같다. 여러 코딩 문제를 써봤는데 이 문제는 기본적인 코딩 실력을 확인하는 데 좋다. 이 문제를 잘 푼다고 코딩을 잘한다고 말하기는 힘들다. 하지만 코딩 실력이 부족한 사람은 쉽게 판단할 수 있다. 반대로 말하면, 코딩을 이제 막 시작한 분들에게 이 정도 문제가 쉽게 느껴지면 초급을 넘는 코딩 실력은 갖춰줬다는 뜻이기도 하다.
>
> 언제나 기본이 제일 중요하다. 주어진 알고리즘을 코드로 옮기는 기본 코딩 능력이 가장 중요하다. 문제 해결 능력은 그 뒤다. 코딩 중에서도 분기문, 반복문, 변수, 수식 같은 기본기가 탄탄해야 한다. 이런 기본기에 소홀하면 릿코드 문제를 몇백 개 풀어도 코딩 면접에서 떨어질 수 있다.
>
> 1. SWE를 ‘스위’라고 미국인들은 보통 읽는다. 충격 받지 않도록 주의. [↩](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fnref:SWE)
> 2. 오죽하면 “나 코딩 인터뷰 준비해”를 요즘 “나 릿코드해”라고 말합니다. [↩](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fnref:LC)
> 3. 이 문제를 내 전공(컴파일러, 코드 최적화, 컴퓨터 구조) 관점에서 본다면 [arbitrary precision](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic) 문제이고 매우 깊게 이야기 할 수 있는 주제이다. [↩](http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/#fnref:ap)

<br><br>

> [경계 무너트리기](http://news.mk.co.kr/column/view.php?year=2019&no=127629)
>
> <br>
>
> 생활고에 짐을 싸야 하는 상황에서 하루를, 어떤 때는 이틀을 햄버거 하나로 지탱하며 지쳐갔다. 무작정 귀국하기로 하고 짐을 싸러 대학 연구실에 간 날, 모처럼 카페테리아에 들러서 하루 식사를 커피 한잔으로 바꾸었다. 옆 테이블에서는 몇 사람이 신호처리 이론의 어떤 난점에 관해 토론하고 있었다. 만사가 귀찮은 사람이 무슨 오지랖인지 "수학에서는 20년 전에 이미 해결된 문제"라며 끼어들었다. 그날 만난 전자공학과의 마르틴 베텔리 교수가 며칠 뒤에 연락을 해왔다. 내가 설명한 수학 논문이 난해하니 자신의 연구그룹에 와서 쉽게 설명해달라고 했다.
>
> 공동 연구가 시작됐고, 그분의 연구장학금으로 나는 무사히 학위를 마쳤고 교수가 되었다. 그렇게 나는 인생의 첫 번째 위기를 넘겼고 새로운 좌우명을 가지게 되었다. 다른 사람들의 생각에 귀 기울일 것, 대화와 논쟁에 참여할 것. 
>
> 고대 그리스 시대부터 연구되어 온 대수기하학이라는 순수수학 분야가 20세기 이후에 출현한 디지털 신호처리이론과 연계될 거라고 누가 예측했을까. 그런 경험을 함께한 은사의 입에서 나온 "의학·공학·자연과학 경계 무너져"라는 말은 수사도 은유도 아니었다. 세상은 연결되어 가고 있고 경계는 무너지는 중이다. 

<br><br>

[테크니컬 아티스트를 위한 추천 서적](https://blog.hybrid3d.dev/69)

<br><br>

[39 studies about human perception in 30 minutes](https://medium.com/@kennelliott/39-studies-about-human-perception-in-30-minutes-4728f9e31a73)

<br><br>

> AI가 배너광고 디자인도 하는 시대다. 100명의 디자이너가 300년간 작업할 량인 1.7억개의 디자인을 뽑아냈다고 한다. 심지어 인간이 만든 것보다 광고효과가 더 뛰어났다. 인공지능(그외 머신러닝, 블록체인 등) 기술력은 이렇게 많은 직업을 없애버릴 것이다. 다들 미래를 체크하라.
>
> [오전 2:51 - 2019년 3월 2일](https://twitter.com/LetUs___Burn/status/1101797211497590785)

<br><br>

> [40대 후반 개발자의 고민에 대하여](https://brunch.co.kr/@nashorn74/18)
>
> <br>
>
> 우선 이 자체는 인정을 받아야 마땅하다. 필자 역시 8비트 DOS 시절을 거쳐서 16비트 DOS에서 32비트 윈도우로 넘어가면서 한바탕 홍역을 치뤘고, C++ 중심의 응용 프로그래밍에서 Java 중심의 웹 프로그래밍, 그리고 또다시 Object-C와 Java 베이스의 모바일 프로그래밍으로 넘어가는 과정을 통과해야 했다. 거기에서 그치는 것이 아니라 Javascript와 Python으로 프론트엔드/백엔드를 아우르는 풀 스택 프로그래밍으로 넘어와서 현재까지 이어질 수 있었다. 말이 쉽지 새로운 기술을 사용하면서 계속 경력을 이어간다는 것이 쉬운일은 아니기 때문이다. 그런데 아쉬운점은, 그럼에도 불구하고 글쓴이가 "나이가 있는데다가 영어를 못해서 해외로 눈을 돌리지 못한다" 라고 댓글을 달았다는 점이다. 24년 동안 새로운 기술에 대한 공부는 열심히 해왔고 앞으로도 공부하겠지만, "영어"는 공부할 생각이 없다는 뜻으로 보이고 굳이 "나이"를 언급하는 것을 보면 외국 생활을 하기는 적합치 않아 보인다. "나이"를 중요하게 생각하고 거기에 얽매는 것은 우리나라를 비롯한 동양권에 제한되는 이야기일 뿐 조금만 밖으로 나오면 "나이"나 "영어"는 우리 인생의 걸림돌이 되지 않는다. 다시 한번 더 말하지만, 독일에서 영어와 독일어를 잘못하는 필자의 친구들이나 동료들은 최소 10년에서 15년 이상 나이 차이가 나지만 같이 어울리거나 일하는데 전혀 지장을 받지 않는다. 

<br><br>

> [[개기자의 개터뷰 #9] 이동욱 배달의민족 개발자 “개발자는 문제 해결사, 재능이 전부가 아니다”](https://www.imaso.co.kr/archives/4869)
>
> <br>
>
> **– 힘들게 SI 회사에 들어갔는데, 재밌었나?**
>
> 다이내믹… 했다.
>
> SI 회사 갔을 때 큰 착각이 발주 금액이 높은 프로젝트가 내 커리어에 좋다고 생각했다. 하지만 신입이 큰 프로젝트에 가면 사용자 테스트, 문서 만들고 그랬다.
>
> 코딩 안 시켜주더라. 테스트만 3개월 하고 그랬다. 10개월 다니다가 퇴사했다.
>
> 
>
> 
> **– 어디로 갔나?**
>
> 포털사이트 줌(ZUM)으로 갔다.
>
> 
>
> 
> **– SI에서 가기 쉽지 않았을 텐데?**
>
> SI 회사 합격 날부터 계속 이력서 썼다.
>
> 2년 차 이하는 중고신입으로 지원할 수 있다 생각했다. 합격 한 날도 이력서 쓰고, 상반기 하반기 다 썼다. 퇴근 후 코딩 테스트도 보러 다니고 그랬다.
>
> 4학년 2학기부터 2년 반 동안 서비스 회사에 이력서를 냈다. 가고 싶은 곳에 이력서를 다 써봤다.
>
> 그러다가 줌에 들어가게 됐다.
>
> 
>
> 
> **– 회사 다니면서 이력서는 언제 준비했나?**
>
> SI는 야근이 언제 끝날지 모르니 무조건 아침에 일찍 출근해서 코딩테스트, 스프링 등 계속 공부했다.
>
> 회사 출근 시간이 9시였는데, 7시 반까지 갔다. 매일 5시 반에 일어나서 6시에 집을 나왔다. SI 시절 10개월 동안 매일 그랬다.
>
> 회식을 3~4시까지 해도 매일 그렇게 했다.
>
> 
>
> 
> **– 주말 출근은 없었나?**
>
> 주말 출근 있었다. 그래도 계속 공부했다. 아예 회사에서 밤새고 일어나 아침에 공부하기도 했다.
>
> 
>
> 
> **– 대단하다… 개발자로서 자괴감 안 들었나?**
>
> … 엄청 많이 들었다.
>
> 친구랑 같이 원룸에서 살았는데, 내가 술 마시고 퇴근해서 난리 치고 그랬단다. 난 기억이 나지 않는다. 같이 살던 친구가 무슨 일 난 줄 알았다더라.
>
> 2년 안에 SI 탈출 못 하면 집으로 내려가려 했다. SI 개발자는 내가 원했던 게 아니었다.
>
> 
>
> 
> **– 뭘 원했나?**
>
> 내 기술력이 느는 게 보이고, 같이 일하는 사람들이 항상 개발 이야기를 하고. 그런 것을 꿈꿨다.
>
> 그런데 SI 회사에서는 영업이 더 중요하니 개발 공부하지 말라고 했다. 나중에 PL(Project Leader), PM(Project Manager) 되면 제안서 발표해야 하니, 그런 걸 준비하라고 했다.

<br><br>

[How should I get started on writing device drivers? ](https://stackoverflow.com/questions/2222763/how-should-i-get-started-on-writing-device-drivers)

[Linux Device Drivers, Third Edition](https://lwn.net/Kernel/LDD3/)

[The Linux Kernel Module Programming Guide](http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html)

<br><br>

> [What are the best resources to learn about the internal workings of Android OS?](https://www.quora.com/What-are-the-best-resources-to-learn-about-the-internal-workings-of-Android-OS)
>
> <br>
>
> [Akash Panchal](https://www.quora.com/profile/Akash-Panchal-5), Worked on AOSP in Bluetooth Stack.
>
> [Answered Oct 29, 2016](https://www.quora.com/What-are-the-best-resources-to-learn-about-the-internal-workings-of-Android-OS/answer/Akash-Panchal-5)
>
> Android is an OS, so the learning the internals is goddamn huge thing. But you can pick and learn particular module.
>
> As an example if you want to understand how Bluetooth works in Android. (From the UI-> Service layer-> Stack-> JNI layer-> Native Stack-> Firmware-> RFComm).
>
> You can find the topology here: [Android Open Source Project](https://source.android.com/devices/bluetooth.html)
>
> Now for the coding part: You can always refer to [official github page of AOSP.](https://github.com/android)
>
> But i would suggest [AndroidXRef](http://androidxref.com/), it is very easy to browse files with neat and clean user-interface. If you understand C and JAVA, you can understand Android.
>
> Hope, This will be enough to start you up.

<br><br>

> [Computer Programmers: I want to learn how to make Android ROM for a device from scratch (using AOSP code). I want to learn everything. From where should I learn? What should I learn?](https://www.quora.com/Computer-Programmers-I-want-to-learn-how-to-make-Android-ROM-for-a-device-from-scratch-using-AOSP-code-I-want-to-learn-everything-From-where-should-I-learn-What-should-I-learn)
>
> <br>
>
> [Nithish Valankumeri](https://www.quora.com/profile/Nithish-Valankumeri), Linux Enthusiast, PC Gamer, Android.. etc
>
> [Answered May 19, 2015](https://www.quora.com/Computer-Programmers-I-want-to-learn-how-to-make-Android-ROM-for-a-device-from-scratch-using-AOSP-code-I-want-to-learn-everything-From-where-should-I-learn-What-should-I-learn/answer/Nithish-Valankumeri)
>
> 
>
> Start with these tutorials.
> [Android Developers - Downloading and Building](https://source.android.com/source/building.html)
> [[GUIDE\] HOWTO: Build your own AOSP ROM](http://androidforums.com/threads/guide-howto-build-your-own-aosp-rom.195756/)
> [Getting Started: Building Android From Source - XDA-University](http://xda-university.com/as-a-developer/getting-started-building-android-from-source)
>
> [XDA-Developers ](http://www.xda-developers.com/)forum is usually able to answer any questions regarding android customization. You should definitely check here.

<br><br>

> [How can one learn Android Kernel Development ? what are good learning resources available?](https://www.quora.com/How-can-one-learn-Android-Kernel-Development-what-are-good-learning-resources-available/answer/Sylvain-Huard-1)
>
> <br>
> Sylvain Huard
> Updated Nov 17, 2013
>
> <br>
>
> I just did that in the past 9 months. **Android Kernel is based on a Linux Kernel 2.6.x.** I use on a regular basis some books:   
> O'Reilly- Understanding The Linux Kernel
> O'Reilly- Linux Device Drivers 3rd edition     
>
> <br>
>
> Make sure you use documents referring to Kernel version 2.6.x and higher since the 2.4.x has significant differences. **You don't need to read and learn everything to start with. I often use those book as reference when needed.**
>
> <br>
>
> **The second step is to practice.** Get the free kernel development platform from google android website. **Then, if you really want to learn, get a development platform.** Yes some real hardware that you can hook-up some devices to it (USB or other). There are many available on the web with price ranging from 400$ and up. Make sure the chosen platform is delivered with a full working Android source kit. **It's always easier to start from something that works and modify it than from completely from scratch.** I started my learning with an off-the shelf Android tablet and it was a nightmare. Even though those manufacturers have to publish the source code because of GPL but, you are never sure if you have the right version for the hardware you have and the information about your hardware is not very accessible. That's why I say use an evaluation board. It's well worth the expense. 
>
> **The third advice is be patient.** When you install the Kernel, you will see over 35000 files getting written on your harddisk just for the Kernel and more than 135000 for Android. **This is a lot and I don't think anybody can master the whole thing. You will acquire knowledge in the area you need and see the rest as black boxes.** When you get stuck, you often find answers using google searches or site like stackoverflow. The tough part is there are thousand more information available on Android application than Android Kernel.
>
> Good luck and enjoy!

<br><br>

[2018년, 내가 모르는 기술들](https://velog.io/@chris/%EB%B2%88%EC%97%AD-2018%EB%85%84-%EB%82%B4%EA%B0%80-%EB%AA%A8%EB%A5%B4%EB%8A%94-%EA%B8%B0%EC%88%A0%EB%93%A4-rnjr3h8mgj)

<br><br>

[A visual guide to Go Memory Allocator from scratch (Golang)](https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed)

<br><br>

> [MLIR Primer: A Compiler Infrastructure for the End of Moore’s Law](https://drive.google.com/file/d/1hUeAJXcAXwz82RXA5VtO5ZoH8cVQhrOK/view) 크리스 래트너 선생 MLIR로 LLVM에서 맺힌 한을 푸시는구나
>
> [오후 8:52 - 2019년 2월 21일](https://twitter.com/summerlight00/status/1098807818453303296)
>
> <br>
>
> 앞으로 구글에서 컴파일러 인력 많이 뽑을 것 같음
>
> [오후 8:55 - 2019년 2월 21일](https://twitter.com/summerlight00/status/1098808423997530112)
>
> <br>
>
> 일단 LLVM에서 못하던 일들 많이 할 수 있는데 nested region 지원 덕분에 polyhedral 모델 같은 것도 훨씬 자연스럽게 지원 가능하다는 모양 다만 난 전문가가 아니라 디테일까진 모름
>
> [오후 9:08 - 2019년 2월 21일](https://twitter.com/summerlight00/status/1098811761346588672)

<br><br>

[Mesh: Compacting Memory Management for C/C++ Applications](https://arxiv.org/abs/1902.04738)

<br><br>

> 안녕하세요 개골님. 컴퓨터 그래픽스나 게임 개발을 하시는 분들도 편미분 방정식을 다루시고, 기계공학을 하시는 분들도 마찬가지이신 것 같은데, 이 두 분야는 연구 대상이 같은 것인가요? 
>
> <br>
>
> [개골](https://ask.fm/cfr0g/answers/153140162282)
> <br>
> 아뇨. 편미분방정식을 쓴다는 점만 같죠. 
> 물론 유체 같은걸 다룬다면 같겠습니다만...

<br><br>

> 기계항공에서도 코딩 능력은 중요하고, 숙련된 코딩 기술은 10년 이상 노력해야 도달할 수 있습니다. 하지만 기계항공공학에서 코딩은 시스템에 대한 이해를 컴퓨터 언어로 쓰는것 이상도 이하도 아닙니다. 시스템 이해를 못하면 코딩 능력은 크게 쓸모가 없거나, 단순번역자 이상의 역할밖에 못합니다
>
> [오전 3:18 - 2019년 2월 16일](https://twitter.com/JongraeK/status/1096730462821777408)

<br>

<br>

> 미국 인증 기관 중에 모 회사... 엄청난 수익율을 자랑합니다. 그 회사가 그렇게 성공한 비결은 단 하나라고 하네요. 고객이 요청하면 무조건 "Yes"라고 했다는 겁니다. 그 당시에는 못 해도 결과적으로 되게 만들었다고 하네요. 사람이 못 하는 일은 거의 없어요. 시간을 단축시키라는 것 빼고요.
>
> [오전 12:41 - 2019년 2월 12일](https://twitter.com/dwkimPNS/status/1095241347399745537)
>
> 돈 버는 법, 성공하는 법은 여러 가지가 있겠지만, "안 되는 것은 안 되는 것"이라고 답하기 전에, "안 되는 것을 되게 하는 방법을 찾는" 쪽이 압도적으로 성공 가능성이 높습니다. 물론 끈기와 노력이 수반될 때 말이죠. 결국 긍정적 생각, 노력, 끈기가 핵심이고 동서고금 같습니다.
>
> [오전 12:43 - 2019년 2월 12일](https://twitter.com/dwkimPNS/status/1095242003435028481)
>
> 그런데, 실패의 이유도 안 되는 것을 되게 하려고 투자는 열심히 했는데 시장이 무르익지 않아서가 가장 많은 것 같아요. 그래서, 실패하지 않으려면 세상보다 딱 반발자국만 앞서 가면 됩니다. 도덕성도 세상보다 딱 반 발자국만 더 엄격하면 됩니다.
>
> [오전 12:46 - 2019년 2월 12일](https://twitter.com/dwkimPNS/status/1095242653736656896)

<br><br>

> 운동이나 영어나 그냥 하루에 A4용지 한 장 쌓기와 다를 바 없어.. 하루에 한 장 쌓아봤자 뭐하나 싶지..그런데 며칠 안 하면 분명 티가 나기 시작해..
> 그냥 하루에 한 장씩 반듯반듯하게 쌓고 또 쌓는 거지. 그러면 몇 개월 뒤에나 이제 조금씩 성과가 보이기 시작..
>
> <img src="https://pbs.twimg.com/media/DzZaGXtV4AASexd.jpg:large">
>
> [오후 1:41 - 2019년 2월 14일](https://twitter.com/GomTaengEe/status/1096162629133856768)

<br><br>

> [Depth-sensing imaging system can peer through fog](http://news.mit.edu/2018/depth-sensing-imaging-system-can-peer-through-fog-0321)
>
> [Wireless communication breaks through water-air barrier](http://news.mit.edu/2018/wireless-communication-through-water-air-0822)
>
> [dspguide.com](http://www.dspguide.com/)
>
> [매체에 따르면 2015년 아마존은 자사 아마존 프라임 비디오의 안정적인 서비스를 위해 초대용량 비디오 압축 포맷 소프트웨어 개발 벤처인 엘레멘털(Elemental)의 인수를 검토했다. 엘레멘털은 이 기술로 올림픽 게임 중계 영상을 온라인으로 스트리밍하거나 위성을 통해 무인항공기(UAV)가 촬영한 영상을 CIA에 안정적으로 전송하는 등 핵심기술로 주목을 받았다.](https://news.v.daum.net/v/20181005185401360)
>
> [Amazon Web Services to Acquire Elemental](https://www.elemental.com/newsroom/press-releases/amazon-web-services-acquire-elemental)

<br><br>

> Today’s most popular standards-based codecs for video streaming are AVC/H.264 and HEVC/H.265. Broadcasters and pay TV operators sometimes still use MPEG-2, which is more than 20 years old. The crucial goal in codec development is to achieve lower bitrates and smaller file sizes while maintaining similar quality to the source. Until fairly recently, most video encoding was performed using specially built hardware chips. AWS Elemental pioneered software-based encoding, which runs on off-the-shelf hardware. <br>
>
> [A Video Compression Primer](https://aws.amazon.com/ko/blogs/media/a-video-compression-primer/)

<br><br>

> 그리고 프로젝트가 뭔가 결과물로 나오는 거 외에도 구현이나 뜯어보고 분석하는것도 되니까 덕질했다는 걸 내놓으래 <br>
>
> A라는 기술에 관심있다 (x) <br>
>
> A라는 기술에 관심있어서 코세라 강의를 듣고 공부했다(x) <br>
>
> A라는 기술에 관심이 있어서 A기술을 공부하다가 구현한 라이브러리를 알게되었는데 그걸 코드 뜯어보니까 이러이러한 단점이 있어서 이러이러하게 개선시켜봤다(o) <br>
>
> from Oracle

<br><br>

> 대학원 때 시간관리 어떻게 하셨나요? <br>
>
> "제가 정말로 열심히 살아야겠다 진지하게 집중해야겠다 생각한 게 박사 때거든요. 박사할 때도 부지런하지 않았고 저는 진짜 한 가지만 생각했어요. 내 인생에 탈출구는 이거 하나 밖에 없다. 주변 이야기를 들어보니까 논문을 좋은 걸 쓰면 잘될 것 같다. 그 다음에 제 이름 밑에 스탠퍼드 이렇게 하나 찍혀보는 게 소원이었어요. 그래서 그거 하나만 집중한거죠. 제 인생 모든 걸 털어부었는데 주말에는 놀았어요. 평생 그런 패턴 한 가지에 집중해서 그것만 하고 주말에는 쉬고 그게 저의 유일한 시간관리 전략이었던 같은데, 요즘 분들이 사실은 불안감 때문에 여러 가지를 하려고 시도를 많이 하시는 것 같아요. " <br>
>
> https://youtu.be/te15EX0gZaw

<br><br>

> 주변에 공부로 성공한? 자들을 보면 몇가지 공통점이 있는데 그중 으뜸은 단연 산만하지 않음이다. 간혹 일하다 웹서핑 좀 하는 것 정도를 산만함과 오해하는 경우가 있는데, 진짜 산만한 사람은 공부 주제가 매일 달라진다. 어떤 날은 AI하다가 어떤 날은 Rails하다가... ㅜㅜ <br>
>
> [오후 11:00 - 2018년 12월 27일](https://twitter.com/bjlee72/status/1078546292635140098)
>
> <br>
>
> 육개월 정도를 한 분야에 갈아넣을수 있는 능력을 가진자가 대체로 남들보다 빨리 감을 잡고 전문가가 되는데 그렇지 못한 나같은 자는 그냥 직장생활이나 잘 해야한다 왜냐 직장이 알아서 주제도 주고 몰입기간도 정해주고... ㅜㅜ <br>
>
> [오후 11:04 - 2018년 12월 27일](https://twitter.com/bjlee72/status/1078547104283320321)

<br><br>

> 개발 일지를 올리지 못할 때가 있지만 프로그래밍 작업은 매일 한다. 대학교 때 공부하면서 느낀 나를 성장시켜 준 근원은 매일 꾸준히 하는 것이었다. 한 번에 많이 프로그래밍하고 몇 일 쉬면 습관으로 만들기 힘들다. 많이 하지는 못하더라도 매일 조금씩 꾸준히 하는 습관이 날 성장하게 만들었다. <br>
>
> [오전 5:45 - 2019년 1월 9일](https://twitter.com/utilforever/status/1082996895444680705)
>
> <br>
>
> 내가 본 정말 훌륭한 개발자분들은 매일 프로그래밍 또는 연구를 하신다. 그리고 정말 꾸준하게 하신다. 그 분들의 내공은 하루 아침에 만들어진 것이 아니라 매일 꾸준히 공부하며 쌓인 경험치라고 생각한다. <br>
>
> [오전 5:47 - 2019년 1월 9일](https://twitter.com/utilforever/status/1082997388996882432)

<br><br>

[좋은 책 하나 잡고 큰 소리로 소리내서 읽으세요. 수준에 따라서 영어 동화책도 좋고 리더스 다이제스트도 좋고 신문이나 소설도 좋습니다. 냉수 한 그릇 옆에 갖다 놓고 목을 축여 가면서 큰 소리로 읽고 또 읽는 겁니다. 책 한 권을 처음부터 끝까지 읽기보다는 한 페이지씩 읽으세요. 한 페이지당 최소 20-30번은 읽어야 하는데 100번 이상 읽어야 될 수도 있습니다. 다음 페이지로 넘어가는 기준은 하도 많이 읽어서 거의 외워져서 다음 문장이 뭐가 나오는지 예상이 될 정도가 되어야 합니다. 단 외우려고 노력하지는 마세요. 어떻게 영어 한 페이지를 다 외웁니까. 천재도 아니고. 그냥 읽는 겁니다. 기억은 입 근육과 혀 근육에 됩니다. 그냥 술술술 나오는 것이죠.](http://ko.usmlelibrary.com/entry/english-common-method?category=187112) 

<br><br>

> 사실 아마존도 유니티를 사기를 원했는데, 유니티가 넘 비싸게 부르는 바람에 (사실 그 부르는 가격대로 샀어야 했음 ㅜ) 포기하고 크라이엔진 3.8 스냅샷을 사옴.. 아무래도그건 아니었는데.. 암튼 그것때문에 내 캐리어도 일부 꼬이고 아마존 퇴사하게 된 결정적인 계기도 되었음 ㅠ 
>
> [오전 10:43 - 2019년 2월 15일](https://twitter.com/teralode/status/1096480087552098304)
>
> <br>
>
> 2015에 unity 를 사기원했다는 저커버그.  이게 이루어졌다면 페북에겐 큰 기회였을듯. 왜 그리 구글, 애플의 생태계에서 벗어나기 원하는지 이해가 될듯.
>
> [오전 2:55 - 2019년 2월 15일](https://twitter.com/sm_park/status/1096362481818030081)

<br><br>

[CPU Clocks and Clock Interrupts, and Their Effects on Schedulers](https://accu.org/index.php/journals/2185)

<br>

> 오스트리아 그라츠공과대학 연구진이, 인텔이 스카이레이크 제품부터 탑재한 보안 기능인 소프트웨어 가드 엑스텐션(SGX)을 역이용해 안티바이러스 소프트웨어가 악성코드 구동을 탐지할 수 없도록 할 수 있는 방법을 밝혔다고…     
>
> [Researchers use Intel SGX to put malware beyond the reach of antivirus software](https://arstechnica.com/gadgets/2019/02/researchers-use-intel-sgx-to-put-malware-beyond-the-reach-of-antivirus-software/)
>
> [오후 5:35 - 2019년 2월 12일](https://twitter.com/metavital/status/1095496704986513408)

<br>

> 쿠킹호일 모자 쓰는 영역으로 진입하면, 최근에는 스트리밍 서비스의 암호화된 영상 패킷 메타데이터를 네트워크에서 분석해서 사용자가 어떤 영상을 보고 있는지 도출할 수 있는 연구[1]나, 암호화된 Tor 트래픽을 네트워크에서 자동 분석해 사용자가 어떤 사이트를 방문하는지 알아내는 연구[2], —
>
> [오후 9:47 - 2019년 2월 12일](https://twitter.com/kid1ng/status/1095559959595560960)
>
> <br>
>
> 스마트폰에서 발생하는 암호화된 패킷을 네트워크에서 분석해 사용자 스마트폰에 어떤 앱이 설치돼 있는지 알아내는 연구[3] 등 암호화의 의미를 기상천외한 방법으로 어떤 방면으로든 무력화하려는 시도가 계속되고 있습니다. —
>
> [오후 9:47 - 2019년 2월 12일](https://twitter.com/kid1ng/status/1095559995737792512)
>
> <br>
>
> [1]: Schuster et al., 2017 [Beauty and the Burst: Remote Identification of Encrypted Video Streams](https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/schuster)
>
> [2]: Rimmer et al., 2018 [Automated Website Fingerprinting through Deep Learning](https://www.ndss-symposium.org/ndss2018/programme/#03A)
>
> [3]: Taylor et al., 2018 [Robust Smartphone App Identification via Encrypted Network Traffic Analysis](https://ieeexplore.ieee.org/abstract/document/8006282)
>
> [오후 9:47 - 2019년 2월 12일](https://twitter.com/kid1ng/status/1095560037102047232)

<br><br>

> 나는 위의 문제를 하나하나 접해가면서 개발자로 커리어 전환을 하였다. 하지만 개발자는 학원의 자극적인 광고만 보고 접근하기엔 위험이 많이 따른다. 그럴 수 밖에 없는게 평생 공부하고 개선하는 과정들을 개발자를 그만두는 그 순간까지 반복해야만하기 때문이다. 나는 첫 회사를 다니면서 2년 동안 개인적인 시간이 거의 없었다. 집에 11시에 들어가면 어머니께서 오늘은 일찍 들어왔다고 말씀하실 정도였다. 일을 위해서 많은 것들을 포기했고 이런 과정들을 지나온 나로서는 학원의 자극적인 광고가 정말 와닿지 않는다. 하루가 멀다하고 학원에서 쏟아져나오는 사람들은 대체로 3년을 버티기가 쉽지않다. 위에서 내가 언급한 문제뿐만 아니라 업무강도도 타 직업군에 비해서 더하면 더했지 덜하지 않기 때문이다. 이는 미디어에서 노출되는 것처럼 행복한 것들만 존재하지 않는다는 것이다. 물론 좋은 점도 많이 있지만 개발을 하는 행위 자체가 취미가 될 수 있는 사람에게나 가능한 장점이 더 많다. <br>
>
> [내가 느낀 비전공자 신입의 문제점](https://medium.com/@rosd0000/%EB%82%B4%EA%B0%80-%EB%8A%90%EB%82%80-%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%8B%A0%EC%9E%85%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90-70c6cfb6626)

<br><br>

> 50세 프로그래머 여성이 15세 아들을 두고 "너는 게임을 좋아하니 게임 개발자가 되렴"이라고 조언한 다음 '그런데 나도 게임을 좋아하잖아? 하지만 난 50세에 여성이지'하고 포기했다가 친구의 "사람은 숫자로 결정되지 않아"라는 말을 듣고 바로 게임 업계에 이력서를 던지기 시작.
>
> [오전 7:22 - 2019년 2월 9일](https://twitter.com/rabapyca/status/1094255281767235585)
>
> <br>
>
> 처음에는 다소 어려움을 겪었지만 기술이 있었기 때문에 MMO 게임의 리스폰에 사용할 생체 시뮬레이션을 개발하던 도중 개발자 포럼에 분석글을 올린게 이력서 역할을 해서 UBI 소프트에 입사(...)
>
> [오전 7:24 - 2019년 2월 9일](https://twitter.com/rabapyca/status/1094255781589876736)
>
> 

<br><br>

> 유명한 UB죠. 저 경우 연산순서를 정하지 않기 때문에 무슨 일이 일어나도 받아들여야 합니다.
>
> > c++
> > int x = 0;
> > cout << x++ << ++x;
> > 이거 1 2임??
> > cout << x++ << x++;
> > 이거 왜  1 0임????
> > cout << ++x << ++x;
> > 이건 또 왜 2 2임??????????
> >
> > [오후 11:40 - 2019년 2월 8일](https://twitter.com/_DAEDU_/status/1094138871548235777)
>
> [오전 12:42 - 2019년 2월 9일](https://twitter.com/pubTirr/status/1094154573873217537)
>
> <br>
>
> 극단적으로는 저걸 실행했더니 펌웨어가 날아가도 받아들여야 합니다...
>
> [오전 12:45 - 2019년 2월 9일](https://twitter.com/pubTirr/status/1094155400562102272)



<br><br>

[How OpenGL works: software rendering in 500 lines of code](https://github.com/ssloy/tinyrenderer/wiki)

<br><br>

> What a great role model: Switzerland has decided that the source code of online voting systems must be published and the systems need to be publicly tested. Bounty up to 50,000 Swiss francs! https://onlinevote-pit.ch/details/ 
>
> [오후 12:01 - 2019년 2월 9일](https://twitter.com/martenmickos/status/1094325483607678976)

<br><br>

> [Oracle Database 12.2.](https://news.ycombinator.com/item?id=18442941)
> It is close to 25 million lines of C code.
>
> What an unimaginable horror! You can't change a single line of code in the product without breaking 1000s of existing tests. Generations of programmers have worked on that code under difficult deadlines and filled the code with all kinds of crap.
>
> Very complex pieces of logic, memory management, context switching, etc. are all held together with thousands of flags. The whole code is ridden with mysterious macros that one cannot decipher without picking a notebook and expanding relevant pats of the macros by hand. It can take a day to two days to really understand what a macro does.
>
> Sometimes one needs to understand the values and the effects of 20 different flag to predict how the code would behave in different situations. Sometimes 100s too! I am not exaggerating.
>
> The only reason why this product is still surviving and still works is due to literally millions of tests!
>
> Here is how the life of an Oracle Database developer is:
>
> - Start working on a new bug.
>
> - Spend two weeks trying to understand the 20 different flags that interact in mysterious ways to cause this bag.
>
> - Add one more flag to handle the new special scenario. Add a few more lines of code that checks this flag and works around the problematic situation and avoids the bug.
>
> - Submit the changes to a test farm consisting of about 100 to 200 servers that would compile the code, build a new Oracle DB, and run the millions of tests in a distributed fashion.
>
> - Go home. Come the next day and work on something else. The tests can take 20 hours to 30 hours to complete.
>
> - Go home. Come the next day and check your farm test results. On a good day, there would be about 100 failing tests. On a bad day, there would be about 1000 failing tests. Pick some of these tests randomly and try to understand what went wrong with your assumptions. Maybe there are some 10 more flags to consider to truly understand the nature of the bug.
>
> - Add a few more flags in an attempt to fix the issue. Submit the changes again for testing. Wait another 20 to 30 hours.
>
> - Rinse and repeat for another two weeks until you get the mysterious incantation of the combination of flags right.
>
> - Finally one fine day you would succeed with 0 tests failing.
>
> - Add a hundred more tests for your new change to ensure that the next developer who has the misfortune of touching this new piece of code never ends up breaking your fix.
>
> - Submit the work for one final round of testing. Then submit it for review. The review itself may take another 2 weeks to 2 months. So now move on to the next bug to work on.
>
> - After 2 weeks to 2 months, when everything is complete, the code would be finally merged into the main branch.
>
> The above is a non-exaggerated description of the life of a programmer in Oracle fixing a bug. Now imagine what horror it is going to be to develop a new feature. It takes 6 months to a year (sometimes two years!) to develop a single small feature (say something like adding a new mode of authentication like support for AD authentication).
>
> The fact that this product even works is nothing short of a miracle!
>
> I don't work for Oracle anymore. Will never work for Oracle again!

<br><br>

[Complete Beginner: Where to Start?](https://forums.unrealengine.com/development-discussion/content-creation/103133-complete-beginner-where-to-start)

<br><br>

> django니 express니 rails니 이딴거 만지니까 왭서버 개발이 쉬워보이는거다. http request header 파싱부터 한땀한땀 다시 짜서 웹서버를 구현해야한다. 회사에서 이짓하면 생산성은 똥망이 되지만 포트폴리오가 되고 기술 딸딸이를 칠수 있으니 좋은 방법이다 <br>
>
> [오전 5:21 - 2019년 1월 31일](https://twitter.com/if1live/status/1090963283819909121)

<br><br>

> 넷플릭스에서 CDN SW/HW를 자체개발해서 사용중인데 운영체제로 FreeBSD를, 더군다나 최신 Head버전에 맞춰 테스트중인 기능만 local diff에 두고 나머지는 모두 업스트림으로 반영중이라네요. 개발팀이 이를 원했고 커미터도 있어서 가능했다고. 이런게 역량이고 실력. https://openconnect.netflix.com/en/software/ <br>
>
> [오후 2:45 - 2019년 2월 4일](https://twitter.com/ksoonson/status/1092554741161152512)

<br><br>

[Original Apollo 11 Guidance Computer (AGC) source code for the command and lunar modules.](https://github.com/chrislgarry/Apollo-11)

<br><br>

> 암기가 얼마나 중요한데. 이해라는 건 알고보면 체계화된 암기일 뿐. 학교 수학도 철저히 암기. 정말 새로운 문제를 창의적으로 푸는 건 수학경시대회에서나. 보통 시험은 이미 풀어본 문제를 살짝 응용. 결국 문제 푼걸 기억하고 있어야 함. 킬러 문항은 타고난 머리 아니면 고액과외(...) <br>
>
> [오후 3:51 - 2019년 1월 28일](https://twitter.com/minjang_kim/status/1090034572488728577)
>
> <br>
>
> 대학교 와서도 암기는 여전히 중요. 공학수학 같은 걸 다 외울 수는 없지만 최소 메타정보, 즉 어디에 이 정보가 있더라 정도는 알면 좋죠. 예를 들어 룽게 쿤타.. 뭐였더라? 요즘 구글 좋으니 이걸 단서로 검색하면 척 나오고 내용 보고 사용하면 되죠. 내용은 까먹어도 이름 정도는 외우면 좋습니다. <br>
>
> [오후 3:51 - 2019년 1월 28일](https://twitter.com/minjang_kim/status/1090034573323448321)

<br>

<br>

[Oracle VM VirtualBox Extension Pack](https://www.virtualbox.org/wiki/Downloads)

<br><br>

[Computational periscopy with an ordinary digital camera](https://www.nature.com/articles/s41586-018-0868-6)

<br><br>

> [How to split a string in C++](https://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/)
>
> ```C++
> // Solution 2: Using boost::split
> 
> #include <boost/algorithm/string.hpp>
>  
> std::string text = "Let me split this into words";
> std::vector<std::string> results;
>  
> boost::split(results, text, [](char c){return c == ' ';});
> ```
>
> <br>
>
> ```C++
> // Solution 3 (for the future): Using ranges
> 
> std::string text = "Let me split this into words";
> auto splitText = text | view::split(' ');
> ```

<br><br>

> 만들 수 있다면 대상에 대해 (엄밀한 수리적 의미는 아니더라고) 직관적인 이해는 했다고 판단할 수 있을까요? 예를 들어, '극한의 엄밀한 정의'는 모르더라도 미분 수치해석을 구현할 수 있다면 미분에 대한 직관적인 이해를 갖춘 것으로 볼 수 있겠지요? <br>
>
> [개골](https://ask.fm/cfr0g/answers/152677731050)
> <br>
> 네. 그 부분에 대한 직관은 생기겠죠, 아무래도. 
> 직관은 여러가지 개념들이 연결되며 팟하고 생겨나는 인식이므로, 개념의 여러측면들을 많이 알수록 직관력도 높아지지 않을까 합니다.

<br><br>

> A warning though.. neither is “easy”. Both languages require that you learn a little bit about how computers work to fully grasp why the languages behave the way that they do. That is hidden from view when programming in JavaScript or Python. <br>
>
> [Is Rust harder to learn than C++?](https://www.quora.com/Is-Rust-harder-to-learn-than-C)

<br>

<br>

> 내가 생각해낼 수 있는 범위 내에서 대안이라고 한다면 코딩과 수학을 결합시키는 것이다. 곡선의 방정식을 배운다면 코딩으로 곡선을 그려보도록 하고 직선과 곡선의 교점을 찾아보게 한다든가, 더 나아가 f=ma를 게임 물리 처럼 직접 코딩하면서 가지고 놀도록 해주면 어떨까? <br>
>
> [내가 생각하는 올바른 코딩 수학 교육](https://blog.naver.com/atelierjpro/221444455822)

<br><br>

> 주니어 개발자 <br>
> 그래도 한국 사람이라고 공부머리는 남아 있어서 나름 대학원을 우수한 성적으로 졸업하고, 멘토링을 해주시던 교수님께서 레퍼런스를 잘 해주셔서 졸업과 동시에 주니어 개발자로 시작을 할 수 있었다. 이게 2007년 11월이었지. 딱 6년 전이네. 나이 서른 중반에 주니어 개발자라니! 그래도 시작했다. 그러고보니 연봉도 지금의 딱 절반 수준이었군. 완전 최저임금만 받고 다닌 거였다. <br>
>
> 그렇게 6년이 흘렀다. 연봉을 올리기 위해 거의 매년 이직을 했고, 인터뷰 때마다 왜 이직이 잦은가에 대한 설명/해명도 해가면서, 조금씩 조금씩 연봉이 올라갔다. 물론, 다양한 업종에서 경력을 쌓아가면서 많은 것들을 배웠고 시야가 점점 넓어지게 됐지. <br>
>
> 시니어 개발자 <br>
> 주니어 개발자로 시작한지 만 6년 만에 드디어 오늘 공식적으로 시니어 개발자가 됐다. 나이 사십에 시니어 개발자가 겨우 됐다. 이십대 중반에 벌써 시니어 개발자 내지는 아키텍트 역할을 시작하는 사람들도 태반인데, 난 이제 시니어 개발자가 됐다. <br>
>
> 이 나라에서 나이는 중요한게 아니라서 먼 길을 돌아돌아 온 감은 있지만, 이제서야 시니어 개발자가 어쨌든 됐다. 지난 반년 동안 계약직으로 대여섯개 어플리케이션을 개발하면서 정말 많이 배웠고, 많이 늘었다. 덕분에 지금 회사에서 인정을 받아 정규직으로 전환했다. 물론 정규직으로 전환되면서 계약직 시절 연봉보다는 턱도 없이 적은 연봉이긴 하다만, 이제 겨우 시니어 개발자로서 명함을 내밀 수 있는 상황에서, 회사에서 내 개발자 커리어의 비전을 보여준 상황에서 기꺼이 받아들였다. <br>
>
> 그러고보니, 주니어때는 지금 연봉의 절반이었지만, 그땐 과외를 많이 해서 지금보다 현찰은 더 많았군. 지금은 과외가 많이 줄어서 월급으로만 먹고 살아야 하다보니 너무 빡세. <br>
>
> https://justinchronicles.net/ko/2013/11/07/became-a-senior-developer/

<br><br>

> > “CEO님께서는 부사장(VP)이나 상무(SVP)가 될 사람을 어떻게 찾습니까?”
> > “저는 본인의 영역 이상의 일을 이미 하는 직원을 찾아서 그들을 진급시킵니다.”
> > 그는 ‘가능성’이나 ‘미래’ 대신에 ‘이미’라는 단어를 사용했다.
> > 이후 나는 매니저들은 그들의 가능성이 아니라 결과를 보고 진급시킨다는 사실을 알게 되었다.
>
> Fearless Salary Negotiation이라는 책의 내용 중 일부이다. <br>
>
> [내가 받은 최고의 커리어 조언](https://iamsang.com/blog/2019/01/01/career-advice/)

<br><br>

> MS가 기술면접 프로세스를 개선하여 구직자들에게 좋은 반응을 얻고 있다고: 수수께끼 같은 질문 배제, 면접 프로세스와 내용을 미리 공유, 실무와 직접 관련된 내용으로 협업하는 형태, 두명의 면접관이 함께 면접 진행 등. 특히 실무를 직접 함께 해본다는 것이 참신하네요. <br>
>
> https://www.inc.com/minda-zetlin/microsoft-changes-job-interview-process-no-more-brain-teasers.html <br>
>
> [오후 4:27 - 2019년 1월 5일](https://twitter.com/ksoonson/status/1081708907351859200)

<br><br>

[미래팩 1.2.2 사각형 안의 점들](https://youtu.be/MlOvGxLNrJI)

<br><br>

[Rico's cheatsheets](<https://devhints.io/>)

<br><br>

[파이썬으로 만드는 나만의 커맨드라인 프로그램 #1 - argparse](https://sjquant.github.io/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-1/)

<br><br>

[Fast inverse square root](https://en.wikipedia.org/wiki/Fast_inverse_square_root)

<br><br>

> *Must read* for web developers: an inside look at how modern browsers work by @kosamari
>
> 1️⃣ https://bit.ly/browsers-pt1 
> 2️⃣ https://bit.ly/browsers-pt2 
> 3️⃣ https://bit.ly/browsers-pt3 
> 4️⃣ https://bit.ly/browsers-pt4 
>
> [오후 11:30 - 2019년 1월 6일](https://twitter.com/addyosmani/status/1082177515618295808)

<br><br>

[How To Learn CSS](https://www.smashingmagazine.com/2019/01/how-to-learn-css/)

<br><br>

[(MAC & PC) macOS Multi Boot USB Project [KEAL-kealOS’es] – Kemal ALKIN – RAW Image](https://www.macosforeveryone.com/mac-pc-macos-multi-boot-usb-project-keal-kealoses-kemal-alkin-raw-image/)

<br><br>

> [도대체 CPU의 캐시는 왜 L1, L2, L3 같은 다층 구조로 구성되어 있는가? ](http://isao76.egloos.com/2595696)
>
> [Why do CPUs have multiple cache levels?](https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/)

<br><br>

> 1.  iamroot.org 사이트 추천합니다.
>    매년 초에 리눅스 OS를 소스레벨에서 분석하는 스터디 모임입니다.(다른 스터디도 있어요)
>     여기 주인장님이 쓰신 "리눅스 커널 내부구조" 라는 책도 추천합니다.
>     사이트는 http://kelp.or.kr/ 라는 사이트도 있어요. 참고하세요.
>    디바이스 드라이버 개발에 관심이 있으면 "유영창"님이 쓰신 "리눅스 디바이스 드라이버" 책 추천해요.
>    http://book.naver.com/bookdb/book_detail.nhn?bid=1477444
>
> <br>
>
> 3. 예전에는 ARM9 기반 보드로 많이 했던거 같은데, 요즘엔 라즈베리파이나 아두이노를 이용해서 이것저것 해보는 게 추세 같아요.
>    엘레파츠나 디바이스마트(오프라인으로도 있어요) 이런대서 살수 있을거에요.
>    http://www.devicemart.co.kr/
>    https://www.eleparts.co.kr
>
> <br>
>
> http://hasunjjang.blogspot.com/2016/08/blog-post_20.html

<br><br>

> 면접에서 물어보는 매번 당황하던 질문이 있었죠. '왜 지원했냐?' 속으로 니네가 광고내서라고 솔직히 답하고 싶었지만 대충 얼버무린 기억입니다. 사실 이 질문의 본뜻은 '네가 지금까지 해온 일에서 이 자리가 네 직업성취에 어떤 발전적인 역할을 하겠냐'라는 걸 한참 나중에 알았습니다. <br>
>
> [오후 4:48 - 2018년 12월 25일](https://twitter.com/JongraeK/status/1077727801887748096)

<br><br>

[The Art of Command Line](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ko.md)

<br><br>

> 이력서를 보면 대기업 출신들의 경우, 어떻게 일을 했는 지 잘 알기 때문에 아무리 이력서가 화려해도 잘 안 보게 된다. 정말이지 내가 본 대기업 출신 엔지니어 중에 전체 그림을 볼 줄은 알아도 실무를 디테일하게 해내는 능력을 갖춘 사람은 소수에 불과했다. <br>
>
> [오전 11:25 - 2018년 12월 22일](https://twitter.com/dwkimPNS/status/1076559314083409920)
>
> 엔지니어링분야가 유독 심할 거라고 본다. 중소기업에서 대기업으로 갈 수는 있어도, 대기업에서 중소기업으로 오는 사례 중에 성공하는 케이스를 보기 어렵다. 회사를 선택하려면 대기업을 가고, 직업을 선택하려면 중소기업이나 중견기업을 가야 한다. <br>
>
> [오전 11:27 - 2018년 12월 22일](https://twitter.com/dwkimPNS/status/1076559760898453504)
>
> 대기업 엔지니어들은 대부분 외주화로 관리업무가 많다. 임원들은 아웃소싱을 더 많이 하길 원한다. 더 많은 아웃풋을 위하여.. 하지만 생산성이 낮은 한국기업들 특성 상, 아웃소싱을 늘리면 내부역량은 점점 약해짐. <br>
>
> [오후 7:02 - 2018년 12월 22일](https://twitter.com/techisart/status/1076674438291017729)
>
> 내 분야의 글로벌기술기업들은 자체개발역량을 같이 키우고 있어서 한국대기업과는 차이가 좀 큰 편. 아웃소싱을 하려면 본인 실력도 어느정도 되야 요구사항을 내는데, 우리는 알아서 잘 해달라는 방식이라 10년이 지나도 실력이 늘지 않음 <br>
>
> [오후 7:08 - 2018년 12월 22일](https://twitter.com/techisart/status/1076675774780850178)
>
> 외주화 방식으로 열심히해서 달성할 수 있는 수준을 넘어가면, 퍼스트 무버가 되어 새로운 것을 만드는 단계에 접어든다. 컨셉 제시 및 구체화를 하는 능력이 필요한데 거기서부터 글로벌 정상급 기업들과 실력차가 나기 시작. 한국 제조업을 포함한 테크기업들이 한계가 여기에 있다. <br>
>
> [오후 7:09 - 2018년 12월 22일](https://twitter.com/techisart/status/1076676144840159232)
>
> 외주화나 베끼기에 익숙한 경우 컨셉설계를 하기보다는 업체찾기나 벤치마킹으로 신기술 개발을 시작한다. <br>
>
> [오후 10:52 - 2018년 12월 22일](https://twitter.com/techisart/status/1076732212022673408)
>
> 그리고 베끼기로 완성하고 나면 자기들 실력이 매우 뛰어난걸로 착각한다. 그리고 결과는 유사한데 내용이 다른경우가 많다. 출력은 같은데 코드구성은 다른 뭐 그런 경우. 결국 다른 걸 만들때 활용이 어려운 경우가 많고 멘붕에 빠진다. <br>
>
> [오전 12:12 - 2018년 12월 23일](https://twitter.com/techisart/status/1076752307059011584)

<br><br>

> 뭘 좀 알겠다 싶으면 이미 늦은 경우가 대부분이다. 잘 몰라도 그냥 치고 나갈 필요가 있다. <br>
>
> [오후 10:58 - 2018년 12월 20일](https://twitter.com/nicehide/status/1076008931359485952)

<br><br>

> # 9. 맺으며
>
> ### *어려움
>
> 개발은 어려웠고, 지금도 어렵고, 앞으로도 어려울 것 같다.
> 뭐든지 빨리 배우는 편이었지만, 29살에 시작한 개발은 생각보다 더 어려웠다.
>
> `이게 왜 안되지?`와 `이게 왜 되지?`라는 벽에 막힐 때가 많았다.
> 그럴 때마다 마음 속으로 한 문장을 떠올렸다.
>
> ```
> "This is not rocket science"
> ```
>
> 우주로 로켓을 쏘는 과학에는 답이 없을 수 있지만,
> 내가 맞이한 이 정도 문제는 반드시 답이 있다고 생각했다.
> 그리고 막막할 정도로 어렵다고 생각된 것들은, 결국 익숙함의 문제인 경우가 많았다.
>
> 우주로 로켓을 쏘지 않는 이상,
> 주니어 개발자로서 정말 어려운 문제를 맞이할 가능성은 낮다고 생각하니, 작은 난관에 청승떨지 않게 되었다.
>
> ### *2018년 소득 1
>
> 학원에 다니던 시절, OKKY에서 진행된 황후순님의 세미나에 참석했었다.
> 세미나가 끝나고 함께 치킨을 먹는 네트워킹 시간이 있었는데, 같은 테이블에 앉은 분들과 자기소개를 했었다.
>
> 이 때 알게 된 [김남준](https://github.com/namjunemy)님과는 그 다음 OKKY 세미나에서 또 만나게 되었고, 지하철역까지 같이 걸어갔다.
> 같이 걸으며 이런 저런 대화를 했고, 헤어지기 전에 서로의 연락처가 아닌 Github 주소를 교환했었다.
> 남준님은 나와 비슷한 부류의 `노력쟁이(?)`라는 느낌이 강하게 들어서 좋았다.
> 남준님은 큰 개발회사에 다니면서 이직을 준비하는 신입 개발자셨고, 열심히 준비하시더니 결국 원하는 회사에 입사하셨다.
>
> 아직 존댓말을 쓸 정도로 가끔 안부를 묻는 사이로 지냈는데,
> 얼마 전에 남준님이 다니는 회사에 나를 추천해주겠다고 연락이 왔다.
> 지금의 나는 알고리즘 테스트에서 떨어질 것이 명백하기 때문에 지원하지 않았지만,
>
> `누군가에게 개발자로서 인정받는 것`은 꽤 기분 좋은 일이었다.
>
> ### *2018년 소득 2
>
> 그리고 일주일 뒤에, 개발자들은 아는 IT전문 컨설팅사의 이사님으로부터 메일을 받았다.
> `블로그 글을 봤는데, 한 번 만나보고 싶다`고 하셨다.
> 유명 개발자들이 이 회사를 통해 이직한 사실은 진작에 알고 있었기에,
> 아직 이룬 것이 하나도 없는 나는 과대평가 받은 것 같았고, 서로의 시간을 아끼고 싶었다.
> 내 초라한 이력서를 보내드리면서, 이력서를 보시고도 만나보실 의향이 있으시면 만나겠다고 했다.
>
> 그래도 만나보길 원하셔서 퇴근 후에 회사 근처 까페에서 만났다.
> 지금 당장 job offer를 주려고 만난 것은 아니지만, 유망주 선점 차원으로 이해해달라고 하셨다.
> 그리고 정말 도움이 많이되는 말씀들을 많이 해주셨다.
> 집에 가서 와이프에게 `"서쪽으로 갔더니 귀인을 만난 것 같다"` 라고 말했을 정도로
> 좋은 회사에서 20년이상 개발하셨던 컨설턴트님으로 부터 귀중한 조언을 정말 많이 들었다.
>
> `누군가 내 미래를 낙관적으로 봐줬다는 것` 또한 꽤 많이 기분 좋은 일이었다.
>
> <br>
>
> https://ryan-han.com/post/2018/essay/memoirs2018/

<br><br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/20181208_173456.jpg">

<br><br>

> https://www.linkedin.com/pulse/pythons-pandas-c-hossein-moein/   
>
> http://projects.icbse.com/subject/cpp    
>
> "이런걸 자잘하게 만들어서 깃헙에 올리래. 그리고 기왕이면 관심있는 수치해석이나 금융 관련 모델을 C++로 구현해서 올리래. 프로젝트가 대단한게 아니고 다양한 구현과 꾸준한 관심을 보여줘야 한대. 한개라도 더 구현해본 사람 좋아한대"

<br><br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/20181204_142107.jpg">

<br><br>

<img src="https://raw.githubusercontent.com/ysjhmtb/blog_images/master/images/posting/20181204_142047.jpg">

<br><br>

> 안녕하세요, 개골님. https://deepmind.com/blog/alphafold/ 를 발견하고 질문드리고 싶은 점이 있습니다. 1) 게임의 규칙이 분명하면 딥러닝은 확실히 강력한 도구인가요? 2) 과학이나 공학에서 (논문으로 출판이 될) 연구 주제들은 게임의 규칙이 분명하다고 봐야 할까요? <br>
> 개골 <br>
> 게임의 규칙이라고 하면 좀 애매하니 바꿔서 말하자면,
> 1) 가능한 패턴의 수는 많지만, 그 패턴을 수학적으로 비교적 명확하게 정의할 수 있고, 정답 패턴과 오답 패턴간의 관계도 정적인 양으로 기술할 수 있으면 딥러닝이 강력합니다. 
> 예를 들어 고전 비디오게임은 2차원 평면에 모든 캐릭터를 매핑 가능하고, 입력도 단순하며, 점수로 정답이 되는 목표를 설정하기 쉬우니 잘 동작했던것이고요.
> 2) 대부분의 문제들은 1)이 아닙니다. 가능한 패턴부터 명확하게 정의 못하는 경우가 많죠. <br>
>
> https://ask.fm/cfr0g/answers/151763419882

<br><br>

[내기니 수현 영어 인터뷰 표현 함께 공부해요! 👩‍🏫 신비한 동물사전2](https://youtu.be/V3pfb2-fjbc)

<br><br>

> **XT**‏ @xtendo_org_ko <br>
>
> 김지현 [@simnalamburt](https://twitter.com/simnalamburt) 의 스타트업 법칙: “충분히 공들인 사기는 스타트업과 구분할 수 없다.” <br>
>
> 오전 4:14 - 2018년 12월 2일 https://twitter.com/xtendo_org_ko/status/1069203125171499008

<br><br>

> 프로의 제일 중요한 덕목은 자신을 아는것과 정직인 것 같다. 모르는 것은 모른다하고, 안되거나 일정이 밀리는 것을 빠르게, 그리고 사실대로 말해주는 것 만으로도 상대에게 큰 안정감을 줄 수 있다. 무리한 일정이나 능력 밖 최선을 한계까지 밀어붙이다가 문제가 터지고서야 알게되는 경우는 최악. <br>
>
> https://twitter.com/wickedev88/status/1068161389540401152 <br>
>
> 하지만 많은 인턴이나 신입들이 부정적인 피드백이 두렵거나 기대를 충족시키지 못할까봐 전전긍긍한다. 나도 그러한 시기가 있었는데, 더 이상 그런식으로 일하지 않는다. 상황을 투명하게 공개할 때 긍정적인 경험(구현 범위를 줄인다던지, 현실적인 대안)을 하게해준 윗분들에게 감사할 따름. <br>
>
> https://twitter.com/wickedev88/status/1068161391826092032 <br>

<br><br>

> Hyun-Ho Shin @shinhh <br>
> 어제 저녁 자리에서 최근의 조직변화에 대한 이야기가 나왔는데, 문득 생각해보니 지난 5년간 연말 리뷰 때 나에게 최악의 평가를 주고 날 다른 팀에 넘겼던 사람은 이번에 짤렸고 나에게 최고의 평가를 줬던 (그래서 나를 임포스터 신드롬에서 구해준) 사람은 지금 초고속 승진을 거듭하고 있다. <br>
>
> 오전 3:12 - 2018년 12월 1일 <br>
>
> https://twitter.com/shinhh/status/1068825145941336064
>
> <br> 그러니 승진을 하고 싶다면 나에게 두둑한 연말 보너스를 안겨라. 후후... #아님 
>
> <br>
> **뉴욕으로 옮기고 나서 한 3년은 극심한 임포스터 신드롬에 시달렸다.**  매일매일 대체 이 회사는 영어도 잘 못하는 나를 왜 뉴욕까지 부른걸까, 내가 지금 밥값을 하고 있는걸까, 혹시 내일 짤리는건 아닐까 늘 불안에 떨었다. 그 때는 사실 회의 때 한 마디도 못하고 나오는 날도 비일비재했으니까.
>
> <br>
>
> 이번 조직 변화 때도 '당장 오늘 면담 때 회사를 나가달라는 이야기를 듣는다고 해도 놀랍지 않다', 라고 생각하며 매일매일 회사에 나갔다. 회사에는 절대우위에서 나만 할 수 있는 일이란 없고 특정 시점의 리소스 상황 안에서 각자 비교우위에 따라 교환할 수 있는 역할만 있을 뿐이니까.
>
> <br>
>
> 뉴욕와서 처음으로 나의 비교우위를 '발견'해준 사람이 (타임라인에서 여러 번 이야기한) 터키 형. 이번 주에 뉴욕 출장에 와서 어제 같이 저녁을 먹었다. 은인 같은 사람이라 언제봐도 반갑다. 그 정도 위치의 분도 불안에 떨게 만들었던 규모의 조직변화였는데 다행히 둘 다 살아남았네.
>
> <br>
>
> 이걸 '발견'이라고 밖에는 설명할 수 없는건 회사라는 곳이 개개인의 특수성에 주목할 수 없는 구조이기 때문. 사람들마다 가지고 있는 그 크고 작은 비교우위가 대부분 발견되지 못한 채 묻히거나 제대도 발휘할 기회도 갖지 못한채 잊혀진다. 그리고 이 '발견'은 전적으로 매니저의 역량에 달려있다.
>
> <br>
>
> 아마 이 터키형이 아니었다면 나도 그렇게 잊혀졌을지도 모른다. 물론 이 한번의 발견이 평생직장을 보장해주는 것도 아님. **잊혀지는 시기를 조금 늦춰줄 뿐이다.** 회사를 오래 다니기 위해서는 누가 내 매니저가 되든 상관없이 '끊임없이 발견되어야 한다'는, 생각을 했다. 생각만으로도 숨막히지만.
>
> <br>
>
> **고용을 '비교우위의 교환'으로 바라보면, 현재의 내 능력만큼이나 어디에 있는지가 중요하다는 것을 깨닫게 됨. 내 능력의 절대치가 높아도 리소스가 넘치는 곳에서 더 뛰어난 사람과 경쟁하면 쉽게 밀려난다. 하지만 능력이 조금 부족하더라도 당장의 리소스가 부족한 곳에서는 살아남을 수 있는 것.**
>
> <br>
>
> 장기적인 커리어 플랜은 이 두가지 큰 틀에서 갈린다. **뛰어난 사람들과 끊임없이 경쟁해서 높은 곳으로 올라갈 것인가, 아니면 내 쓰임이 발견될 수 있는 곳을 찾아다니며 살 것인가.** 후자라고 쉬운 것은 아니라는 것이 함정. 한국의 대기업은 전자만 가능하고 후자의 옵션이 없다는 느낌.

<br><br>

> 개골님. "물리학자는 학부 물리학과에서 배우는 수준 이상의 수학이 필요한가요?"라는 질문에 "세부 전공따라 천차만별이죠. 이론물리학(특히 우주관련) 가면 아예 만들어 쓰기도 하고.."라는 답변을 해주셨는데요. 무언가를 새롭게 만들지 않고 수치해석으로 근사해만 구해서 경향을 파악하는 것으로는 부족한가요? 
>
> <br>개골
> <br>
> 현상을 설명하는 방정식이 나와있으면 그럴테고, 좋은게 없다면 수학적 틀을 만들겠죠. 방정식을 푸는 것도 좋은 수치해석 방법론이 있다면 쓸테고, 없다면 만들테고... 새로운 현상을 연구할 일이 많을 수록 새로운 걸 만들어야하는 경우가 많아지는 겁니다.
>
> <br>
>
> https://ask.fm/cfr0g/answers/151674170602

<br><br>

> “머신러닝에 수학이 필요한가?” 오늘날의 머신러닝 응용에 함수해석학은 그다지 필요가 없다. 하지만 20대에 함수해석학을 공부해두 않으면 나중에 그걸 공부해서 함수해석학이 필요한 일을 할 수 있을 가능성은 매우매우매우 낮다. 20대 초반이라면 이런 관점에서 투자해야 한다. <br>
>
> https://twitter.com/d_ijk_stra/status/1066601532219518977

<br><br>

[작은 오픈소스 프로그램을 분석해서 실력을 쌓아 나간 사례](https://okky.kr/article/408595?fbclid=IwAR1ZIxswItTr69wniNhXaiWuV2YezBWrEOJrWIBuZl573QyQ2l_X9aocduY)

<br><br>

> 금요일, 11월 23, 2018 <br>
> [B급 프로그래머] 데이터 과학자로 취직하려면 남들처럼 하지 마라. 
>
> <br>
>
> 오늘은 [To get hired as a data scientist, don’t follow the herd](https://towardsdatascience.com/the-economics-of-getting-hired-as-a-data-scientist-e3882933b43c)라는 흥미로운 글을 소개해드리겠다. 데이터 과학자로 취직하기 위한 방법은 무엇일까? 
>
> <br>
>
> 대부분의 사람들은 다음과 같은 과정을 (무한) 반복한다.
>
>  <br>
>
> 1. 먼저 기초 지식(파이썬+sklearn+Pandas+SQL이나 다른 뭔가)를 배운다
> 2. 그리고 나서, 판에 박은 MOOC를 수강한다
> 3. 몇몇 직무 기술서를 보고 나서, 자격 조건에 미달한다는 사실을 걱정한다
> 4. 다른 MOOC를 듣거나 실제로 지원해본다
> 5. 소득이 없다(잘 해봐야 몇몇 면접에서 폭탄을 맞을테다)
> 6. 좌절해서 석사 과정에 대해 생각하면서 더 많이 지원한다.
> 7. 결정의 시간이 왔다: 다른 뭔가를 기대하면서 2번부터 7번까지 반복해야 하나?
>
>  <br>
>
> 하지만 다른 사람들도 다 하기 때문에 명백히 밟아야 할 코스라면 피해야 마땅할 것이다. 그렇다면 어떤 전략을 구사해야 할까? 다음 다섯 가지 전략이 유효하다. 
>
> <br>
>
> 1. 논문을 따라해보자: 특히 딥러닝을 할 경우에 유용한 방법이다. 다른 사람들이 이렇게 하지 않는 이유는 손쉽게 데이터를 가져다가 판에 박은 알고리즘에 적용하는 과정에 비해 어렵기 때문이다. 관심 있는 (기왕이면 최신) 논문을 읽고 이해하고 따라해서 블로그에 올려보자.
> 2. 안전 구역에서 편안하게 지내지 말자: 프로젝트를 새로 시작한다면, 새로운 프레임워크/라이브러리/도구를 배우는 편이 좋다.
> 3. 따분한 일을 배우자: 어느 누구도 따분한 일은 좋아하지 않기 때문에 사람들은 따분한 일을 하지 않늕다. 도커 사용법, Flask를 사용한 앱 개발 방법, AWS나 구글 클라우드에 모델 배포하는 방법 등은 회사가 지원자에게 간절히 원하는 기술이지만, 대다수 지원자들은 이를 저평가한다.
> 4. 짜증나는 일을 하자. 지역 데이터 과학자 밋업에 논문을 제출하거나 최소한 참석이라도 해보자. 링크드인에 들어가서 모르는 사람에게 메시지를 보내보자. 스터디 그룹을 시작하자.
> 5. 미친 듯이 보이는 일을 하자. 사람들은 미리 가공된 몇몇 주식 데이터셋을 사용해 프로젝트를 만들 것이다. 그러지 말고 웹 스크래핑 라이브러리 사용 방법을 배우거나 직접 데이터셋을 구축하기 위해 몇몇 저평가된 API를 활용하자. 데이터는 저절로 얻어지지 않으며, 회사는 종종 엔지니어들이 직접 수집한 데이터에 의존할 필요가 있다. 여러분의 목표를 정리하자면... 작업을 마치기 위해 필요하다면 빌어먹을 데이터셋을 직접 구축할만큼 데이터 과학에 미친 광인이 되어야 한다.
>
> ------
>
> 추가: 단순 예제만 반복하다가 끝나는 경우를 많이 목격했다. 학원이나 MOOC나 독서가 중요하긴 하지만 정말 자신이 풀고 싶은 문제를 하나 정해서 데이터 수집부터 분석과 시각화에 이르는 일련의 과정을 밟아볼 필요가 있다. 혹시 이 블로그 애독자 여러분들 중에서 데이터 과학자가 되기 위해 열심히 뭔가를 해봤지만 여전히 방향을 잡지 못하는 분들이 계시면 댓글이나 이메일로 도움을 요청하시라. 작지만 조금이라도 도움을 줄 수 있는 방법이 있으면 도와드릴테니까...
>
>  <br>
>
> EOB
>
> http://jhrogue.blogspot.com/2018/11/b_23.html 

<br><br>

> redacted @minjang_kim <br>
> 아마존이나 여기나 모두 장애로 난리군. 내 기준으로 "컴퓨터 잘 하는 사람"은 이런 장애 문제점 찾고 해결하는 사람들. 정말 대단함. 나 같은 리눅스 맹은 도저히 범접할 수 없는 영역. tmux 문제도 제대로 해결 못해서 짜증만 내고 리붓하는 사람. tmux source-file ~/.tmux.conf를 몰라서
>
> [오후 4:23 - 2018년 11월 21일](https://twitter.com/minjang_kim/status/1065400400596033536)

<br><br>

> Ji Yun Park @Jiyun_Park <br>
> 창의성이란 '과거의 경험과 지식, 정보를 통합, 분해, 연결, 재해석, 분리하여 새로운 관점의 해결책을 내놓는 과정'
> ->"새로운 조합을 만드는 능력" - 피터 드러커 <br>
>
> 오후 6:39 - 2011년 4월 21일 <br>
>
> https://twitter.com/Jiyun_Park/status/61242764809080832

<br><br>

> Noori Lee @noori_lee <br>
> 살다 보면 육아나 원치 않는 직장 등에 매진하느라 삶이 허비된다고 느낄 수 있음.
> 그러나 세상에 쓸모없는 경험이란 없다고 봄. 다만 TV 시청이나 인터넷 게임은 예외.
> **특히 양질의 독서만 유지한다면 괜히 불안해할 필요 없이 적절한 시기를 기다리면 됨.**  <br>
>
> [오전 7:35 - 2018년 11월 19일](https://twitter.com/noori_lee/status/1064542680095420417)
>
> Noori Lee @noori_lee <br>
> 인생은 절대 원하는 대로 풀리지 않음.
> 그렇다고 목표를 세울 필요가 없다는 건 아니고, 정말 가치 있는 목표를 세웠으면 온 힘을 쏟으며 그에 따른 결과의 형태를 겸허히 받아들이란 말임.
> 솔직히 젊을 때 상상하는 목표나 결과란 게 유치하기 짝이 없잖음.
>
> Noori Lee @noori_lee <br>
> 최대의 악순환은 늘 자신의 인생이 허비된다고 느끼면서, 거기서 오는 불안감을 잊기 위해 또는 일종의 보상으로써 오히려 인생을 제대로 허비하는 헛짓에 더더욱 매진하게 되는 거지.
> 물론 누구에게나 지 인생을 망칠 자유는 있는 거니까.

<br><br>

> minchul park @summerlight00 <br>
> ㅋㅋㅋ 한국 세금 많다는 이야기 들으면 웃지요 여기 100k가 실수령 기준으로 보통 3할 정도 빠지는데 비슷한 소득 분위인 한국 5천이 2할도 안 되던가 그럴거 
>
> [오전 10:11 - 2018년 11월 20일](https://twitter.com/summerlight00/status/1064944358296772608)

<br><br>

[Geoff Hinton: On Radiology](https://www.youtube.com/watch?v=2HMPRXstSvQ&feature=youtu.be)

<br><br>

[Why Grit Is More Important Than IQ When You're Trying To Become Successful](https://www.forbes.com/sites/lisaquast/2017/03/06/why-grit-is-more-important-than-iq-when-youre-trying-to-become-successful/amp/?utm_source=FACEBOOK&utm_medium=social&utm_term=Malorie%2F&__twitter_impression=true)

<br><br>

> YD Lee, 李永斗 @enhance <br>
> 어려운 책 읽는 법
> '뉴턴은 데카르트의 기하학을 읽으면서 두어 쪽에서부터 헤맸다. 다시 읽으니 겨우 서너 쪽이 이해됐다. 이렇게 진도를 나가다가 다시 방향을 잃고 처음부터 다시 읽기 시작하며 거듭 읽어나가며 마침내 전체 내용을 완전히 이해했다.' 에드워드 돌닉 <뉴턴의 시계> 278쪽 <br>
>
> [오후 11:57 - 2018년 11월 18일](https://twitter.com/enhance/status/1064427553341923328)

<br><br>

> [A Brief Outline of 106 Linux Commands with Examples](https://linoxide.com/linux-how-to/linux-commands-brief-outline-examples/)
>
> [GIT CHEAT SHEET](https://www.git-tower.com/blog/git-cheat-sheet)

<br><br>

> [학생들은 보통 공부를 하다가 알 것 같다는 기분이 들면 그 내용은 그만 공부하고 다음 내용으로 넘어가게 된다. 문제는 그 기분이 별로 정확하지 않다는 것이다. 그래서 실제로는 잘 모르는데도 충분히 공부를 안하게 된다. ](http://169254.tumblr.com/post/92633286949/%EB%A8%B8%EB%A6%AC-%EB%82%98%EC%81%98%EB%A9%B4-%EA%B3%B5%EB%B6%80%ED%95%B4%EB%8F%84-%EC%86%8C%EC%9A%A9%EC%9D%B4-%EC%97%86%EC%9D%84%EA%B9%8C)

<br><br>

> 사업을 시작한 지 3년, 이제는 나의 불공평한 장점이 무엇인지 알 것 같다. 사업을 해보면 정말 분명하게 알 수 있다. 남들보다 내가 잘하는 것이 무엇인지, 그리고 나에게 부족하기 때문에 다른 사람들에 맡겨야 하는 것이 무엇인지. 몇 가지 떠오르는 나의 장점은 아래와 같다.
>
> - **부지런함, 그리고 꾸준함**: 일을 하다보면 잘 되는 날도 있고, 생각대로 진행되지 않는 날도 많다. 그리고 물론 포기하고 싶은 때도 생긴다. 하지만 결국, 나는 고등학교 3년 생활을 통해 훈련을 받은 대로, 부지런하게, 그리고 꾸준하게 매일 조금씩의 성취를 만들었고, 그것들이 3년간 모이자 그럭 저럭 무언가가 이루어진 느낌이다. 내가 이렇게 하루 하루를 보낼 수 있게 해주는 가장 큰 원천 중 하나는 아침 운동이다. 아침에 일어나면 바로 짐(gym)에 가서 하루를 시작하는 습관을 2년 전부터 가지게 되었는데, 운동으로 하루를 시작하면 저녁 9시가 되기까지 피곤함을 안느낀다. 이 생활을 꾸준히 하다 보니, 이제 사정이 있어서 며칠 운동을 쉬면 힘이 없고 의사 결정도 흐리멍텅해지는 것을 느낄 정도.
> - **빠른 의사 결정 능력**: 사업이라는 것은 결국, 수백, 수천가지 의사 결정의 집합체이다. 하나하나 세어보지는 않았지만, 내가 한 주에 내리는 의사 결정이 작은 것까지 포함해서 최소한 100개는 되는 것 같다. 이 의사 결정을 빠르게 하는 것이 무척 중요한 게, 직원들과 파트너들, 그리고 고객들의 움직임이 내 의사 결정에 따라 결정되고, 그 속도 또한 여기에 좌우를 받는다. 제품에 대한 의사 결정, 사람을 뽑는 의사 결정, 그리고 마케팅 지출에 대한 의사 결정들을 나는 굉장히 빨리 내리는 편이다. 물론, 그 때문에 잘못된 의사 결정을 내리는 경우도 종종 있지만, 또 다른 빠른 의사 결정을 통해 그 일이 더 크게 잘못되거나 지출이 더 커지는 것을 막는다. 조금 어려운 의사 결정은 하루 이틀 정도 두고 본다. 그 다음날이 되어도, 또 그 다음날이 되어도 같은 결론에 도달한다 싶으면 그 때 결정을 내린다. 가장 긴 시간을 두고 생각했던 건 사람을 내보내는 일이었다. 한 달을 고민했다. 앞으로는 조금 더 빨리 할 수 있을 것 같다.
> - **새로운 분야에 대한 용기**: 뭐랄까, 한국에서 교육을 받은 장점이랄까. 나는 내가 모르는 분야에 대한 두려움이 별로 없고, 배우면 그만이라는 생각을 많이 한다. 고등학교 때부터 자신의 좋아하는 분야를 결정하고 점점 그 쪽으로만 능력 개발을 하도록 유도하는 미국의 교육과 달리, 한국에서는 모든 과목을 두루 다 잘해야 한다. 국어, 영어, 수학, 과학, 정치, 사회, 문화, 역사, 외교, 도덕, 체육, 음악, 미술,… 초등학교 때부터 고등학교 졸업 때까지 모든 분야를 커버하고 외우는 훈련을 반복해서가 아닐까 하는데, 내가 처음 접하는 지식에 대해 별로 두려움이나 거부감이 없다. 전자공학을 전공했다는 것도 여기에 한 몫 하는 것 같다. ‘어떻게 인간의 머리로 이런 것을 이해할 수 있지?’ 하는 생각을 하며 당시에 끙끙거리며 공부했었는데, 특히 전자장 Electromagnatism이 가장 어려웠다. 이 수업을 들어 본 사람은 안다. 이건 사람의 머리로 소화할 수 있는 게 아니라는 것을. 결국 이 수업에서 C 학점을 받았던 것으로 기억한다. 이 수업을 경험하고 나니 세상의 모든 지식은 시간만 충분히 투자한다면 인간의 머리로 이해할 수 있고, 더 나아가 마스터할 수 있다고 생각하게 됐다.
> - **경험**: 분명히 정의내리기 어려운 영역인데, 사업을 시작하기 전에 15년간 스타트업에서, 그리고 대기업에서 일했던 것이 많이 도움이 된다는 생각을 자주 한다. 특히 직원들을 대할 때, 그리고 그들의 입장에서 그들의 마음을 이해하려고 노력할 때. 내가 윗사람에게 어떤 대접을 받았을 때, 그리고 윗사람이 나를 어떻게 대했을 때 내가 가장 신이 나고 즐겁게 일할 수 있었는지 자주 생각을 한다. 그리고 그렇게 직원들을 대하려고 노력을 많이 한다. **그 중 가장 큰 건 믿어주는 것이다**. 예를 들어, 우리 회사 직원들은 모두 법인 카드를 가지고 있는데, 이것으로 점심 식사를 원하는 대로 사먹을 수 있고, 주유도 할 수 있고, 일하는 데 필요한 것들을 살 수 있다. 그렇다고 해서 그들이 마음 대로 쓰는 것은 결코 아니지만, 그것이 기분이 좋은 일임을 알고 있다. 나도 그러한 경험을 해 봤기에. 또 한가지, 우리 회사에는 연차 제도가 없다. 붐비는 시기를 피해 원할 때 휴가를 가고, 며칠 어디 가는지 세지도 않는다. 그리고 휴가와 일을 결합해서, 일주일은 쉬고, 일주일은 현지에서 일하는 방식으로 하기도 한다. 그리고 나 역시 그런 식으로 일을 한다.
>
> **What is your unfair advantage?** 지금도 항상 하고, 그리고 앞으로도 자주 나에게 하게 될 질문이다.
>
> https://sungmooncho.com/2018/11/16/unfair-advantage/ 

<br><br>

> 박상민 / Sang-Min Park @sm_park <br>
> 오늘 인터뷰는 워즈니악 전성기 얼굴에 버금가는 비주얼의 학생. 얼굴과 치렁치렁 머리가 일급 너드였는데 예상대로 코딩, os 네트웍 지식이 대박. 이 바닥은 일단 얼굴이 먹어줘야한다. <br>
>
> [오후 11:29 - 2018년 11월 16일](https://twitter.com/sm_park/status/1063695504444276736)

<br><br>

[Too Late To Start? Life Crisis and Late Bloomers – Infographic](https://blog.adioma.com/too-late-to-start-life-crisis-infographic/)

<br><br>

[Estimating the chances of something that hasn’t happened yet](https://www.johndcook.com/blog/2010/03/30/statistical-rule-of-three/)

<br><br>

> Rinae @adhrinae <br>
>
> https://github.com/GoogleChromeLabs 
>
> 이번에 웹 컴포넌트 관련 조사하다 깨달은건데
> 여기서 소스코드 보면 진짜 배울게 많다. 주석 하나하나 기능 설명도 해주지, 타입스크립트로 되어있지, 작은 웹 컴포넌트 구현체들부터 코드 들여다보면 도움 많이될 듯
>
> [오전 6:34 - 2018년 11월 15일](https://twitter.com/adhrinae/status/1063077844002078720)

<br><br>

> Marco Arment  @marcoarment <br>
> You can’t use joins at Twitter’s scale.
>
> You can barely even use databases.
>
> Immense scale makes simple database operations much, much more complicated in practice.  <br>
>
> [오전 5:25 - 2018년 11월 13일](https://twitter.com/marcoarment/status/1062335574525259776)
>
> <br>
>
> James @jamescampbell <br>
> @marcoarment 님에게 보내는 답글 <br>
> As a DBA for like 15 years, just add a new table called edited_tweet that joins on original tweet_id. Make sure this new table is propagated to all servers before rolling out front end changes. Test with beta users. Make tweet editable once*. Done. Not a big deal. Ive had worse. <br>
>
> [오전 4:39 - 2018년 11월 13일](https://twitter.com/jamescampbell/status/1062323962179411968)

<br><br>

[요즘 학생들이 제대로 공부하기 어려운 이유](https://youtu.be/gHsaF9gAfyM)

<br><br>

> Park JaeHo @jrogue <br>The cult of creativity is making us less creative https://qz.com/1450975/  via @qz 한 줄 요약: 창의성은 하늘에서 뚝 떨어지지 않으며, 엄청난 시간, 노력, 학습이 선행되어야 한다.

<br><br>

> blanche @blancheiswhite <br>
> '한 그룹은 학위 논문을 마치는 데 ‘수년이 걸리는 학생들’이었고, 또 한 그룹은 ‘2년 이내에 마치는 학생들’ 이었다. 놀랍게도 두 그룹은 지적 수준이나 정서 상태에서는 거의 차이를 보이지 않았다. 다만 두 그룹의 실질적인 차이는 후자의 학생들이 ‘더 힘들어한다’는 것뿐이었다. '
>
> [오전 4:18 - 2018년 11월 12일](https://twitter.com/blancheiswhite/status/1061956415533633536)
>
> <br>
>
> blanche @blancheiswhite <br>
> '이 학생들의 공통점은 아래와 같았다.
>   • 자신의 삶을 대기 중이라고 여긴다. 온종일 논문만 작성하느라 다른 모든 계획은 하나도 안 세우고 파티나 친구들과의 약속, 운동은 전부 논문을 마친 후로 미룬다'
>
> <br>
>
> blanche @blancheiswhite <br>
> '논문을 미루는 학생들의 상당수는 몸매도 엉망이었고, 숙소도 각종 과제물, 책, 오랫동안 씻지 않은 커피잔, 벗어 놓은 더러운 옷들로 난장판이었다. 한 학생은 ‘논문에 대해서는 노코멘트!’라고 적힌 티셔츠를 입고 다니기도 했다.'
>
> <br>
>
> blanche @blancheiswhite <br>
> '그러나 1년 안에 학위논문을 마치는 데 훌륭한 진척을 보인 학생들은 여가 시간을 꼼꼼히 챙겼다. 그들은 논문을 잘 쓰기 위한 전체적인 계획에 건강과 휴식을 필수사항으로 놓고 여기에 높은 우선순위를 부여했다.' 
>
> 내 시간 우선 생활습관 | 닐 피오레, 김진희 저
>
> <br>
>
> blanche  @blancheiswhite <br>
> *타래의 첫 트윗에 후자가 아니라 전자입니다.

<br>

<br>

> "만들려고 배우지 말고, 배우기 위해 만들어라"에 동의하시나요?
>
> <br>[개골](https://ask.fm/cfr0g/answers/151360822250)
>
> <br>
> 그냥 선후가 따로 있나 싶어요

<br><br>

> Dae San Hwang @daesanhwang 
>
> <br>
> 개발자는 기술적으로 도전적인 작업을 해야 실력이 는다. 혹여 프로젝트가 실패하더라도, 그래야 남는게 있고 나중에 다른 작업을 할때 베이스 레벨의 기준이 달라진다. 
>
> <br>
>
> [오후 11:06 - 2018년 11월 7일](https://twitter.com/daesanhwang/status/1060428298868510720)
>
> <br>
>
> Dae San Hwang
>
> <br>문제는 스스로 열정을 가진 도전적인 과제를 찾기가 생각보다 쉽지 않다는 점이다. 무언가 만들고 싶은게 있고, 그것을 만드는게 기존의 오픈소스 라이브러리만으로 충분하지 않을때, 필요한 무엇을 직접 만드는 일이 그런 도전적인 프로젝트를 찾는 좋은 방법일 수 있다.
>
> <br>
>
> Dae San Hwang
>
> <br>
>
> 또는 기존에 쓰던 오픈소스 프레임워크가 점점 더 bloatware 가 돼갈때, 자신의 작업 효율성을 제고하기 위해서 대체 프레임워크를 직접 만드는 일도 한가지 방법일 수 있다.
>
> <br>
>
> Dae San Hwang
>
> <br>
>
> 또는 뽈레팀의 개발 인턴쉽에 참여하는 것도 좋은 방법일 수 있다. 뽈레팀은 웹개발 프레임워크, ORM 프레임워크, 검색엔진, 큐처리 프레임워크, 자바스크립트 프레임워크/트랜스파일러, 지오코딩 엔진 등의 기술을 자체 보유한 "실리콘밸리를 이기자" 가 개발팀 모토인 스타트업이다.
>
> <br>
>
> Dae San Hwang
>
> <br>
>
> 뽈레팀 개발 인턴은 시스템 레벨 프로그래밍 언어 만들기, 그 언어로 iOS/안드로이드 개발이 가능하도록 확장하기, (구글 지도 같은) 지도 sdk/렌더링엔진 개발, 모바일 UI 개발 프레임워크, 스크립트 언어 구현 등 현재 뽈레 개발팀에서 진행중인 프로젝트 중 하나에 주도적으로 참여하게 됩니다.
>
> <br>
>
> Dae San Hwang
>
> <br>이런 프로젝트에 참여하고 싶은 분들은 희망 분야와 자신이 왜 그 개발을 잘 해낼 수 있는지 과거 공부/개발 경험 위주로 기술된 자기소개서와 이력서를 daesan@polle.com 으로 보내주시기 바랍니다. 프로젝트 기간은 주제와 목표 범위에 따라 3~6개월 정도일 예정이고 근무지는 광화문 위워크입니다.
>
> <br>
>
> Dae San Hwang
>
> <br>지원 후 3일 이내로 면접 여부를 회신드릴 예정이고, 이메일로 사전 인터뷰가 진행될 수 있습니다. 많은 개발자/학생 분들의 관심 부탁드립니다.
>
> <br>

<br><br>

> 정겨울 @res_tin
>
> <br>개발자 이력서를 어떻게 작성하면 좋을지 안내한다. 글에서는 1페이지로, 중요한걸 먼저, 일관된 레이아웃과 폰트 사용을 강조하며 회사 경험이 없다면 개인 프로젝트를 중점적으로 채울 것을 권한다.
>
> <br>
>
> [How to write a killer Software Engineering résumé](https://medium.freecodecamp.org/writing-a-killer-software-engineering-resume-b11c91ef699d)
>
> <br>
>
> [오후 11:03 - 2018년 11월 7일](https://twitter.com/res_tin/status/1060427447823302656)

<br><br>

[Real science. Now in real time.](https://cseweb.ucsd.edu/~jmcauley/?fbclid=IwAR2ldcIZ4TIuGd9KnngJSdD_Xo98yuV_kBiL5H6HSrdEHClYrTaOxNFkhtg)

<br><br>

> You don’t have to complete all of the sections at once to get the value out of this tutorial. Try to get as far as you can — even if it’s one or two sections. <br>
>
> It’s fine to copy and paste code as you’re following along the tutorial, but we recommend to type it by hand. This will help you develop a muscle memory and a stronger understanding. <br>
>
> https://reactjs.org/tutorial/tutorial.html  
>

<br><br>

> 안녕하세요 개골님. 언제나 좋은 답변 감사드립니다. 말씀하셨던 것처럼 알고리즘 문제를 풀때 여러 테스트 케이스를 다 만족시키지 못하면 결국 틀린 것이지요. 알면서도 일반화 된 해결책을 코드로 옳길 능력이 아직 부족한데요. 결국 경험의 부족이겠지요? 
>
> <br>
> [개골](https://ask.fm/cfr0g/answers/151254417898)
>
> <br>
>
> 하다보면 늘겠죠. 문제를 풀때는 직접 로직을 만드는 방법도 있지만, 누군가 이미 잘 만들어놓은 다른 로직을 가져다 쓰는 경우가 더 많거든요. 로직을 많이 아는 것은 경험/공부하다보면 느니까요.

<br><br>

> asbubam @asbubam <br>
> https://stdout.fm/  
> 코딩할 때 재밌게 듣고있는 팟캐스트. 에피소드 더 많이 올라오면 좋겠다. <br>
>
> [오후 5:46 - 2018년 11월 4일](https://twitter.com/asbubam/status/1059260741667049472)

<br><br>

[머리도 쓰면 좋아져요](https://youtu.be/vrvN_itJ9as)

<br><br>

>  JBD @rakyll <br>
> Engineer. Diagnostics at Google Cloud. Keeping things boring. Personal opinions. <br>
> Nov. 02, 2018  <br>
> Google's interview system is not great but there are various reasons why it feels less than it is. Most candidates don't know what the goal of our interviews are. First rule, it is not about finding an optimal solution or any solution at all. 
>
> <br>
>
> You are interviewed for multiple skills simultaneously. Cognitive skills, communication, leadership are a few to name. If the point is not finding a solution, then what is it? Let me explain.
>
> <br>
>
> Your interviewers try to understand what it feels like to work with you on a daily basis. An interview question is just a tool in achieving that, it is not there to specifically measure your skills on a topic but a tool to understand the depth of your thinking.
>
> <br>
>
> Before the interview starts, ask them what they want to get out of this interview. Good interviewers should already have a plan and a set of expectations. Ask them what you should do. Don't start coding yet. Ask them you should produce. Discussion, diagrams, pseudo code, code?
>
> <br>
>
> Then, start cracking the question. List whatever questions you think it is important to solve this question, ask your edge cases. Get to a point where you are discussing about pros/cons of the solutions. These steps are critical. Don't just start coding. Have a consensus first.
>
> <br>
>
> Your interviewer will try to give you hints. Don't ignore them because you are too confident about your solution. This is not a smartness contest. Also, don't panic if a hint doesn't make sense. Ask what interview's perspective is that they gave that hint.
>
> <br>
>
> Talk, talk, talk as you are doing your thing. Talk about even the most obvious steps. Ask about testing, talk about testing cases if testing discussion is expected. Discuss what you'd fix to iterate your solution if you realized you are missing something.
>
> <br>
>
> Don't get freaked out if the interviewer jumps to a different question. Sometimes, they think they got enough of what they have been looking for from a question and will do something else. Don't try to overdo a solution if interviewer think it is good enough.
>
> <br>
>
> If you are not highly senior, you won't get asked system design or open ended questions about industry best practices. This style of interviews are also about being able to discuss pros/cons.
>
> <br>
>
> Don't freak out just because your interviewer is taking too many notes. They need to provide evidence to the hiring committee and they want to remember as many signals as possible. Make sure you are clearly communicating your new ideas if you are iterating on the initial ones.
>
> <br>
>
> At any interview regardless it is at Google or not, don't see your interviewer as someone who has the full authority but some who you are already working with. Try to have a feel how productive it will feel in real life. Remember, interviews shouldn't be a monologue.
>
> <br>https://threader.app/thread/1058433116002381824

<br><br>

> Hacker News @newsycombinator
>
> <br>[So You Want to Learn Physics (2016)](https://www.susanjfowler.com/blog/2016/8/13/so-you-want-to-learn-physics)
>
> [오전 3:01 - 2018년 11월 4일](https://twitter.com/newsycombinator/status/1059037884219617280)

<br><br>

> Hilary Mason @hmason
>
> <br>
>
> When you want to use a new algorithm that you don't deeply understand, the best approach is to implement it yourself to learn how it works, and then use a library to benefit from robust code.
>
> <br>
>
> [Here's one article showing this with neural networks in Python](https://towardsdatascience.com/how-to-build-your-own-neural-network-from-scratch-in-python-68998a08e4f6)
>
> [오전 10:36 - 2018년 11월 3일](https://twitter.com/hmason/status/1058774912201035776)

<br><br>

> 김성완 (kaswan) @idgmatrix
>
> <br>페이스북이 음성 서비스를 만들지 못한 게 기본적으로 2년은 걸리는 일을 관리자들이 반년만에 해내라고 엔지니어들을 압박하는 바람에 결국은 5년이 지나도 결과물이 얻을 수 없었다는 이야기네요. 
>
> <br>
>
> [How Facebook Failed To Build A Better Alexa (Or Siri)](https://www.forbes.com/sites/parmyolson/2018/10/30/on-mute-how-facebook-fell-behind-on-voice-technology/#4ac32afb3b50)
>
> <br>
>
> [오후 10:43 - 2018년 10월 31일](https://twitter.com/idgmatrix/status/1057870695315660801)

<br><br>

> GreekSage @GreekSage
>
> <br>보통 현실이 불만족스럽지만 다른 대안을 찾아 나서지 못하는 이유는 실패가 두렵기 때문이다. 성취란 실패없이 이뤄지진 않는다는걸 알면서도.
> 자신 인생에 그 어떤 추구하는 궁긍적 성취가 있다면 가장 먼저 해야할 것은 실패다. 인생은 그럴 가치가 있다.
>
> <br>
>
> [오후 11:38 - 2018년 10월 30일](https://twitter.com/GreekSage/status/1057522115312869376)

<br><br>

> 상당수의 문제를 재귀로 풀 수 있을까요?
>
> <br>개골
>
> <br>
>
> 네
>
> https://ask.fm/cfr0g/answers/151132240618

<br><br>

> [외국어 공부 어떻게 할까](https://1boon.kakao.com/bookclub/curation20181020)
>
> <br>
>
> 존경하는 선생님 한 분은 제자들에게 고전 한문을 가르칠 때 교재 한 권을 떼고 나면 반드시 입으로 소리를 내서 300독을 하라고 숙제를 내주신다고 한다. 그런데 정말로 300번을 읽는 학생도 있다고 한다. 300번을 읽으면 통째로 외지는 못한다 하더라도 한 구절이나 한 단어만 운을 떼면 나머지는 저절로 줄줄 나오게 되어 있다.
>
> <br>
>
> 대부분 외국어 공부를 하는 사람들은 너무 구체적으로 목적을 세우고 빨리 성취를 하려고 한다. 몇 개월 만에 HSK(한어수평고시)나 JPT(일본어능력시험) 시험을 봐서 몇 급을 따고 몇 단계를 통과하겠다고 성급하게 군다. 한두 달 외국어를 배웠다고 금방 외국어를 할 수 있는 것은 아니다. 서두르면 도리어 이루지 못한다. 언어는 서두른다고 해서 능숙해지지 않는다.

<br><br>

> 방위병 시절, 저는 야간 근무를 하며 하루 12시간씩 전화 교환대 앞을 지켰습니다. 밤에는 전화가 거의 오지 않아요. 멍하니 앉아서 스위치보드를 보는 게 일이었지요. 근무 중에 책을 펼쳐놓고 공부할 수도 없었어요. 하도 심심해서 저는 짬짬이 출근 전에 외운 영어 문장을 암송했습니다. 기억 속의 회화문을 불러내는 겁니다. 때로는 손바닥으로 가린 조그만 종이쪽지에 영어 키워드를 적어뒀어요. 첫 단어를 보면 전체 문장을 떠올릴 수 있거든요. 매일 앉아서 허공을 보며, 하루 10문장씩 외우니 한 달에 300문장, 1년이면 3600개 문장을 외울 수 있었어요. 아니, 실제로는 더 많이 외웠어요. 뒤에 갈수록 더 잘 외워지더군요. 하도 잘 외워지는 게 신기해서 진도를 많이 나갔습니다. 책을 보니 그 시절 영어책 암기가 쉬웠던 이유를 알 수 있었어요.
>
> 벼락치기 공부는 단기 기억에는 용이할지 몰라도, (시험 전날 공부해서 성적 올리는 정도만 유효) 장기 기억에는 도움이 되지 않는답니다. (벼락치기가 수능에 안 통하는 이유, 범위가 너무 방대하고 말 그대로 수학 능력을 평가하기에 단기 기억 승부가 아닙니다.
>
> http://free2world.tistory.com/1091

<br><br>

```bash
# 2018 10 18 
# WinSCP와 MobaXterm 사용.
# bash로 처음으로 빌드해 본 경험.

# ots_gg_1014> 에서
# source build/envsetup.sh
# lunch
# 44
# make otapackage
$ cd vendor/kaon/CT1107
$ vi version.txt
# version 하나 증가. e, i, :wq!
$ cd ../../../
$ cd out/target/product/CT1107
$ ls
$ rm -rf CT1107-ota-eng.root.zip
$ cd ../../../../
$ make otapackage
# at /home/sslee/work/ots_gg2_1014
$ find ./-name "CT1107*.zip"
# at /home/sslee/work/ots_gg2_1014/out/target/product/CT1107


# ftp
# 전송하고 싶은 파일이 들어있는 폴더로 이동.
$ ftp kkms.kaonmedia.com
# id / pwd
$ cd 위치시킬폴더
$ bin
$ hash
$ mput *

# 전송받는 서버에서 확인하기.
$ ssh id@kkms.kaonmedia.com
# pwd
$ ls -l



# TeraTerm
# 펌웨어 마운트 여부
$ cat /proc/mtd
# 펌웨어 버전 확인
$ getprop | grep firmware

$ ifconfig

# 시리얼 넘버
$ cd hwcfg
$ cat serialno



#부트로더 upgrade 방법 (w/ bolt command)
# 1.	Usbdisk 에 첨부된 이미지를 copy 후 SET에 연결.
# 2.	부팅 시 Ctrl+C 로 prompt 진입
# 3.	flash usbdisk0:CT1107_BOOTLOADER_DEV_1_34_06.BIN flash0
# 4.	reboot


# 커널 버전 확인하기
$ uname -a

# 프로세서 정보
$ cat /proc/cpuinfo

# CPU Implementer : Your code means ARM
# CPU architecture : AArch64 means 64 bit ARM board

# 파일 찾기
$ find ./ -name "bolt*"




# 저전력 들어 간 상태 확인 방법
# 현재 상태에서 red led 나온 후 2분 뒤 test
 
# logcat 확인 방법
 
$ logcat NEXUS:* Brcmstb-PowerHAL,PLGG_POWER,PLGG_LED,frontledservice,gg_kaon_amp,EepromService,AmpService:V PowerManagerService:V libsuspend:V nxwrap:V *:S
 
$ logcat NEXUS:* Brcmstb-PowerHAL,PLGG_POWER,PLGG_LED,frontledservice,gg_kaon_amp,EepromService,AmpService:V *:S
 
# 순서
$ logcat -c
 
$ logcat -G 15M
 
$ logcat NEXUS:* Brcmstb-PowerHAL,PLGG_POWER,PLGG_LED,frontledservice,gg_kaon_amp,EepromService,AmpService:V *:S
 
 
# 저전력 진입 log
 
$ 11-20 20:54:36.523 2803 2959 I Brcmstb-PowerHAL: power_set_state: Successfully set power state S2
 
# 버튼을 사용하지 않고 펌웨어 업그레이드
 
$ cas setflags FIRMWARE_USB 1
$ reboot

# 전력 플래그 확인
$ getprop | grep pwr
 
 

# pm command

# 모든 apk display
pm list package
kt apk list display
pm list package | grep kt

# disable 된 apk display
pm list package –d
pm enable apk
pm disable apk




logcat | grep alticard
mount   # ext4 확인
/mnt # cas ~> /resolved/cas 확인
/mnt/cas/$ touch 1320 # check after reboot

```

<br><br>

>  [Technical Interview Guidelines for beginners](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)
>
> [2019 카카오 신입 공채 1차 코딩 테스트 문제 해설](http://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/)
>
> [카카오 신입 공채 1차 코딩 테스트 문제 해설](http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/)
>
> [카카오 신입 공채 2차 코딩 테스트 문제 해설](http://tech.kakao.com/2017/10/24/kakao-blind-recruitment-round-2/)
>
> [카카오 신입 공채 3차 코딩 테스트 문제 해설](http://tech.kakao.com/2017/11/14/kakao-blind-recruitment-round-3/)

<br><br>

> [리액트 네이티브 서울](https://www.meetup.com/ko-KR/react-native-seoul/?chapter_analytics_code=UA-44056140-15)
>
> [ABOUT SUJIN LEE](https://sujinlee.me/about/)
>
> [신입 소프트웨어 엔지니어의 영문 이력서 작성하기](https://sujinlee.me/entry-level-en-resume/)
>
> [Write down your resume with Markdown and generate pdf, docx and deploy website ](https://github.com/sujinleeme/resume-generator)
>
> [월드잡플러스](https://www.worldjob.or.kr/intro.do)

<br><br>

> [[B급 프로그래머] 초급 개발자가 알아야 하는 12가지 기술](http://jhrogue.blogspot.com/2018/10/b-12.html)
>
> <br>
>
> [12 Things Every Junior Developer Should Learn](https://dev.to/ben/12-things-every-junior-developer-should-learn-lco)
>
> <br>
>
> 초급 개발자가 알아야 하는 12가지 기술은?(순서 무관)
>
> - 관계형 데이터베이스 동작 방식(언제나 유용)
> - 일반적인 HTTP 동작 방식
> - 특정 언어에서 코드 디버깅 방법(다른 언어에서도 엇비슷하므로 지식을 재사용할 수 있다)
> - 코드를 찾는 방법(IDE나 명령행에서 grep을 사용)
> - 정규 표현식 기초(직전 항목에서 코드를 찾는 방법에도 적용 가능)
> - 검색 엔진으로 직면한 문제의 해법을 찾는 방법
> - git 운영 방법(다른 형상 관리 시스템이라도 큰 문제 없음)
> - 질문할 가치가 없다고 생각할 때에도 질문하기
> - 시간대(TZ) 동작 방식(농담이 아님. 많은 개발자들이 혼동을 겪는 부분임)
> - 유니코드와 UTF-8 동작 방식
> - 캐시 동작 방식(CPU, 메모리, 디스크)
>
> 여기에 IDE 사용 방법(자유자재로...)과 셸/CMD 기초 사용법, 네트워크 관련 일반 지식이 더해지면 초급 개발자로서 한 몫을 다 하리라 생각한다.

<br><br>

[정운찬 = 아까 기업들이 규제 때문에 투자 안 한다는 것이 과장이라고 한 또 다른 이유는 최근 20년간 대기업도 중소기업도 투자를 하지 않았다는 점 때문이다. 특히 10대 그룹 사내유보금은 650조원에 달한다. 이렇게 돈이 많은데도 투자를 안 하는 이유는 핵심기술이 없기 때문이다. 연구·개발(R&D)비 지출이 절대적으로는 세계 5·6등이라는데 거품이 끼어 있다. 정부가 세금 깎아준다고 하니 R&D 지출을 잔뜩 잡아놓는데 들여다보면 거품이 있다는 말이다. 그리고 대부분 D(개발)이지 R(연구)이 아니다. 한국의 대기업은 핵심·첨단 기술을 더 확보해야 한다. 따라서 D에서 R로 방향을 전환해 개발보다 연구를 더 늘려야 한다. 그런데 그것은 시간이 많이 걸린다. 중소기업들은 투자를 하고 싶은데 돈이 없다. 대기업의 돈이 합법적으로, 부드럽게 중소기업으로 흐르도록 해야 한다.](http://news.khan.co.kr/kh_news/khan_art_view.html?art_id=201810050600005)

<br><br>

> [Chris Ohk @utilforever](https://twitter.com/utilforever/status/1048131856833474560)
>
> <br>
>
> 대학원 면접 때 물어봤던 첫 문제. 공부 방식을 깨닫게 해 준 문제.
> 힙이란 무엇인지 설명해보자 → 힙의 구조를 그림으로 그려보자 → 힙에 데이터를 삽입/삭제하는 방식을 말해보자 → 삽입/삭제하는 동작의 시간 복잡도를 말해보자 → 데이터가 어떻게 들어와야 최상/최악의 경우가 되는지 말해보자

<br><br>

[DP 28 shooting](https://www.youtube.com/watch?v=ZGDJk0_6pUE&feature=youtu.be)

<br><br>

[실리콘밸리보다 베를린인 이유](https://iamsang.com/blog/2017/10/30/berlin-over-silicon-valley/)

<br><br>

> [영화 '플래쉬 오브 지니어스'로 알아보는 지식재산권](https://blog.naver.com/kipoworld2/221362775574)
>
> <br>
>
>  지식재산권을 두고 벌인 12년의 싸움 그 결과는 로버트 박사의 승소로 막을 내리고 포드 자동차 회사를 포함한, 자신의 특허 기술을 무단으로 사용한 여러 자동차 회사들에게 어마어마한 금액의 배상금을 받아냅니다. 이때 승소의 결정적 부분이자, 영화에서 지식재산권을 정확하게 묘사하고 있는 장면이 나오는데요. 법정에서 로버트 박사는 포드 자동차 회사가 고용한 사람에게 **‘로버트 박사 당신이 와이퍼를 직접 개발한 것도 아니고, 단지 여러 부품들을 다르게 배열한 것일 뿐이지 않소?!’라고 공격받습니다.** 이에 로버트 박사는 차분하게 큰아들에게 사전과 소설책을 받아 옵니다. 로버트 박사가 들고 온 소설책은 누구나 그 이름을 들으면 알 수 있는 세계적인 작가 찰스 디킨스의 책이었습니다. 로버트 박사는 법정에서 소설책의 한 구절을 읽어줍니다. **그리고 여기 책에 ‘it’, ‘was’와 같은 수없이 등장하는 단어들이 모두 찰스 디킨스 작가가가 만들어낸 단어들인지 반문을 하며 반박합니다. **
>
> <br>
>
> ■ 창조는 재배열 하는 것
>
> <br>
>
> **로버트 박사의 말처럼 세상에 큰 변화를 가져온 많은 발명품들 모두 부품들을 어떻게 설계하느냐에 따라 만들어진 결과물입니다.** 비행기를 처음 만들 라이트 형제들도 비행기에 들어가는 부품을 개발한 것이 아니라 기존의 부품들을 비행할 수 있도록 새롭게 설계한 것이죠. 남이 개발한 지식재산권을 무단으로 도용하고 발뺌하는 뻔뻔스러운 사람들에게 강력한 일침을 가하는 영화, 플래쉬 오브 지니어스였습니다. 지식재산권을 왜 존중하고 지켜 줘야 하는지 의문을 제기하시는 분들이 계시다면 이 영화를 보며 정답을 한 번 찾아보시길 권해드립니다.

<br><br>

>  [왜 45세 정년이 될 수 밖에 없는가 (기술기업의 관점에서) ](http://windy96.egloos.com/3495731)
>
> <br>
>
> 2014/10/15 18:22
>
> <br>
>
> 부인하기 어려운 사실 중 하나는 한국은 원천기술, 기반기술이 취약하고 응용기술만 발달했다는 것이다. 특히 공학 쪽에서는 상당히 많은 부분의 기술이 미국와 일본의 발달된 인프라에 의존하고 있다. 반도체를 예로 들자면, **생산에 관련한 다수의 장치**는 일본과 미국의 전문업체에 의존하고 있고, **설계에 관련한 툴들도** 모두 미국 기술에 의존하고 있다. 반도체 시장의 규모의 경제 때문에 이런 식으로 분업이 이루어지는 것은 세계적인 트렌드이지만, 한국이 그 중에서 어떤 부분에서 중심 역할을 담당하고 있지 못하다는 것은, 반도체 업계에서 가진 위치에 비해 초라하다.
>
> <br>
>
> 차원을 좀더 끌어올려서 소프트웨어 혹은 지적재산권에 연관해서 생각해보면, 더욱더 취약하다. 한국에서 만들어진 **프로세서나 운영체제, 컴파일러, 데이터베이스** 중에서 세계적으로 유의미한 점유율을 가진 것이 없다. 미국 빼곤 다른 나라들도 마찬가지 아니냐고 말할 수 있지만, 심지어 다 같이 쓰는 리눅스에서도 한국 사람들이 기여한 바는 매우 적다. **Linux나 gcc, apache**에서 한국 사람 이름 보는 것이 그렇게 쉬운 일이 아니며, 그나마 한국 사람이 commit에 깊게 관여되어 있기도 한 **hadoop** 같은 경우는, 사실 그 분은 미국 회사 소속으로 일을 하고 있는 것이다. 순수히 한국에서 이런 프로젝트에 기여하는 바는 0에 가깝다고 단언할 수 있다.
>
> <br>
>
> 이렇게 기반 기술에 대해서 연구, 공부가 부족하다 보니, 할 줄 아는 것이라고는 가져와서 쓰는 것이다. **그리고 가져와서 쓰기 위해서는 매뉴얼을 읽고 이해하는 것이 필요한데, 이를 위해서 영어가 필요하다.** 실제로 반도체 설계에 사용되는 툴이나 다른 기업이 만든 IP를 가져와서 칩을 제작하는 경우에, 기업에서 실제로 필요한 인력은 **영어로 된 문서를 읽고 빨리 어떻게 돌아가는지를 파악하고 그것을 실제 제품에 적용하는 능력**을 갖춘 인력이다. 현장에서 목격한 바로는 이걸 제일 잘 하는 애들은 좋은 대학에서 석사를 마치고 들어와서 몇년 경력을 쌓은 애들이다. 이들은 6+3+3+4+2(석사까지)=18년 동안 공교육, 사교육 열심히 받아서 배운 능력으로 남이 만든 기술을 어떻게 이용할 수 있는가를 '익히는데' 젊음을 바치고 있다. 
>
> <br>
>
> 서글프게도 이 모습은 70, 80년대 공장의 모습과 크게 다르지 않다. 4년제 대졸자가 하던 수준의 일을, 이제는 대학원 나온 석사들이 한다는 것이 달라졌을 뿐이다. 당시 신문 지상을 장식하던, 미국 기업과의 기술제휴 혹은 기술이전을 떠올려보자. 이런 기술을 받아오기 위해서는 기계가 어떻게 돌아가는지 공정을 어떻게 셋업해야 하는지를 배워와야 했고, 좋은 대학 나오고, 영어 문서를 독해할 수 있는 인력들이 파견되어서 혹은 미국에서 온 엔지니어에게 교육을 받아가면서 공장을 셋업했다. (그 때는 몰랐다. 왜 미국기업이 돈 벌 수 있는 기술을 무료로 혹은 염가로 이전해주는지를. 알고 보니 그게 전부 노동 집약적, 24시간 공장을 돌려야 해서 미국에서는 그런 일을 할 인력을 구할 수 없어서, 혹은 환경 파괴나 산업 재해 때문에 할 수 없는 것들을 후진국으로 옮기는 작업이었다.)
>
> <br>
>
> 이렇게 남의 것을 습득하는 것에 머무르다 보니, 실제로 머리를 써야 하는 것은 단순한 트릭 같은 것이다. 어떤 문제 상황이 주어졌을 때, 이것이 가진 의미가 무엇인가, 왜 이런 문제가 발생했는가, 일반해를 찾자면 어떻게 되는가, 더 좋은 방법은 없는가와 같은 고민은 전혀 하지 않은 채, 3일 내로 이 문제가 발생하는 것을 막으려면 툴에서 무슨 옵션을 써야 하는가와 같은 지극히 '실용적인' 문제로 치환하게 된다. 문제의 본질을 해결하려는 노력을 하지 않기 때문에, 딱히 대단한 기술 개발이 되지를 않는다. **전부 ad hoc 방식으로 해결하고, 논문이나 특허로 발전시키기 힘든, 혹은 그 수준이 높지 않은 것이 되기 십상이다. **
>
> <br>
>
> 사실 이게 모든 악의 근원이다. 기술력의 부재. 원천기술의 부재. 단순히 뭔가를 뚝딱뚝딱 해서 돌아가는 것을 만들면 되기에 더 깊이 생각하지 않고, 단순 작업을 하고. 그러다 보니 숙달되는데 시간의 차이가 있을지언정, 어느 정도 하고 나면 누구나 다 비슷해진다. 그래서 개발을 10년 하면 전부 매니저 트랙으로 간다. 어떤 사람은 5년만에 모든 걸 깨우치고 매니징 능력을 갖추기도 하고, 어떤 사람은 7년이 걸리기도 하지만, 어쨌거나 정도의 차이는 있을지언정, 10년 쯤 지나면 조금더 빨리 하고 아니고 정도만 차이가 나지, 다 비슷비슷한 실력을 갖추게 된다. 
>
> <br>
>
> 여기서 기업은 선택을 한다. 이만큼 숙련된 애들을 어떻게 써먹을 것인가. 대부분의 선택은 일부는 남기고 나머지는 자른다는 것이다. 승진할 수 있는 인력의 수를 제한하고, 그 문턱을 못 넘은 사람들은 조직에서 밀려난다. 이건 조직이 발전하기 위해서 그럴 수 있다 치더라도, 문제는 그렇게 해서 살아남은 사람들이다. **이미 이들은 대부분 숙련되었고, 딱히 더 익힐 능력이 없다. 새롭게 만들어지는 기술에 적응하는 문제만 남았지, 본질적으로 문제 해결 능력이라든지 창의력이라든지 통찰력 같은 것은 그다지 필요하지 않다.** 그러면 여기서 조직에 어필하는 방법은 둘 중 하나다. 하나는 윗선에 잘 보여서 줄을 잘 타는 것이고, 다른 하나는 아랫사람들을 쪼아서 성과를 내는 것이다. 어차피 일 자체가 대단한 창의력과 머리를 필요로 하지 않기 때문에, 대체로 투입 시간과 성과가 비례하고, 그래서 회사에 야근을 많이 하는 사람이 '양적으로' 더 많은 일을 해낸다. 그래서 가족과 생이별을 하고, 회사에 남아서 자기 밑의 사람들을 퇴근 못하게 하고, 자기도 남아서 열심히 야근을 하면 더 많은 성과를 올린다. 그렇게 남의 가족도 생이별을 시키고, 노총각 노처녀를 만드는데 조금이나마 보탬이 된다.
>
> <br>
>
> 비극은 여기서 그치지 않는다. 호경기, 기업이 잘 나갈 때는 문제가 없지만, 경기가 위축되거나 시장 점유율이 떨어질 때가 문제다. 해마다 기업에는 '잉여 관리자'들이 양산된다. 이미 5년 10년이면 매니징을 할 수 있는 능력이 되는데, 15년 20년 된 사람들을 높은 연봉을 줘가면서, 심지어 자녀 학자금까지 줘가면서 데리고 있을 이유가 없는 것이다. 그래서 명예퇴직을 시키고, 조직을 개편한다. 아니, 심지어 기업이 잘 나가고 있더라도, 더 높은 자본이익율 달성을 위해서 인력 감축을 상시로 한다. 이런 식의 특별한 명분 없는 layoff는 '구조조정'이라는 그럴듯한 말로 포장되고, 조직에 건전한 긴장관계를 만들어서 성과를 높인다는 식으로 어용경제연구소에서 열심히 보고서를 쓰고 언론에서 발표한다.
>
> <br>
>
> 자, 그래서 이 과정에서 버티지 못하고 나온 사람은? 할 일이 없다. 중소기업에 가서 '매니저' 일을 계속 하거나, 치킨집 차리는 것이다. 딱히 대단한 기술이 필요없는 직종에서 이러는 것은 미안하지만, 어쩔 수 없다고 볼 수 있다. 하지만 전문적인 기술, 특히나 기술집약적인 산업에 종사하는 사람도 이렇게 밖에 할 수 없는 것은 그 기술집약이라는 것이 남의 것을 사와서 내가 이용하는 식의 '집약'이었기 때문이다. 그래서 미국 회사에는 종종 나이 많은, 백발이 성성한 프로그래머가 보이기도 하는데, 한국에선 그런 사람이 있을 수 없는 것이다. **java를 만들고, java를 더 효율적으로 실행하기 위한 기술을 개발하던 사람은** 어디 가든 쓸모가 있지만, **java 응용 프로그램 중에서 어느 파트를 하나 맡아서, 이를 테면 클라이언트단에서 통신 프로그래밍을 주로 하던 사람은** 그 기술이 도태되고, 새로운 기술이 사용될 때, 새로운 기술을 익힌 젊고 인건비가 싼 인력으로 대체된다. **기술 개발을 하는 사람은 '정년'이 없지만, 기술 이용을 하는 사람은 정년이 빨리 온다.**
>
> <br>
>
>
> 이 문제를 해결하는 것은 참으로 어렵다. 우리 나라가 그 분야 기술의 이니셔티브를 쥔다면 문제는 해결된다. 말은 쉽지만, 이게 쉬운 일인가. 몇가지 예를 들자면 이렇다. 기업이 단순 노가다가 아닌 근본 기술을 확보하고 그것을 통해서 이윤을 창출한다는 생각을 가져야 한다. 정부는 실제로 이런 이윤 창출이 가능하도록 특허 출원을 원하는 기업에는 지원을 해주고, 오픈소스에 대한 작업을 대학과 기업에서 많이 할 수 있게끔 프로젝트 지원을 해야 한다. 별 의미도 없는 이상한 자격증 몇개 가지는 대신에, 오픈소스 활동 경력을 기업에서 더 인정해준다면 그것도 좋은 방법이 될 수 있다. 그리고 무엇보다도 기반 기술을 개발하는 기업에 대해서 지원해주고, 대학에서 기업으로 발전하는 스타트업 경로를 더 많이 열어줘야 한다. 미국 정부가 컴퓨터 기술 발전에 얼마나 많은 돈을 투자했고, 얼마나 많은 오픈소스가 그것들을 바탕으로 생겨났으며, 또 얼마나 많은 상업화 시도가 일어났는가를 상상해보라. 그냥 거저 얻어지는 결과가 아니다. 엄청난 투자가 필요하다. 이런 것 없이는 제아무리 석사 박사를 해도 결국 45세 치킨집 신세를 면하기 힘들고, 18년 공부해서 18년 돈 벌이도 못하는 결과가 생겨난다. 당장 무슨 핸드폰 5, 6가 나오는게 중요한게 아니고, 이런걸 가이드할 수 있는 정부, 정치세력이어야지, 일자리를 챙길 수 있는, 장기적인 수권능력을 가진 세력이 되는 것이다. 

<br><br>

> redacted @29979245oo
>
> <br>@tiny_wings_ 님, @Rainyvale 님, @d_ijk_stra 님에게 보내는 답글 <br>
> "리트코드 달달 돌리고 와서 잘 푸는 사람도 많을거 같은데..." => 바로 티나요. 약간만 꼬아서 내봐요. 논리적 전개 과정에서 막힙니다. 코딩을 쓰는데 unreachable 코드 써버리고 if else에도 헛점이 보여요. 요즘 릿코드 문제 수백개라서 다 푸는 것은 불가능합니다. <br>
>
> [오후 2:30 - 2018년 10월 6일](https://twitter.com/29979245oo/status/1048687063095074816)

<br><br>

```
김민장 2018 04 07

요즘은 "코딩 인터뷰 준비한다"가 아예 I'm leetcoding 으로 통하는군. 구글링, 우버링에 이은 릿코딩! 크래킹 코딩 인터뷰 이런 책 말고 그냥 릿코드만 보세요. 다만 문제 많이 푸는 것에 집착하는데 정확하게 푸는게 훨씬 중요. 그러니 실제 면접에서 풀었는데도 떨어지는 일이 빈번.

그리고 제발 다이나믹 프로그래밍 이런 거에 시간 허비 하지 말라고. 왜 여기에 그렇게 시간 쓰는지 너무 안타깝다. DP 문제 나오면 그냥 브루트 포스로 풀어요. 그 담에 메모이제이션해서 조금만 최적화 해도 됨. 그런데 이보다 코딩을 잘 해야 함. 대부분은 잘 못합니다. 누가 지적 안 하면 모름.

뜬금 없지만 여기서 학교에서 코딩 교육 시킨다고 개발자 임금이 하락하느니 다들 코딩 잘 하겠느니 이런 소리를 자주 듣는데 전혀 동의 안 함. 학교에서 수학 시킨다고 수학 잘 하던가요. 수포자만 늘죠. 코포자가 곧 나옵니다. 코딩 어려워요. 누구나 할 수는 있지만 잘 하는 건 너무 어려움.


영어에 고통받는 월급루팡 프로그래머

그렇게해도 합격되나요? 몰랐던 사실이네요...


김민장

네 전혀 상관 없습니다. 다이나믹 프로그래밍은 평가가 극과 극입니다. 대부분은 아예 손도 못 대고 일부 문제를 외운 사람과 정말 천재인 사람으로 나뉩니다. 좋은 문제가 아니에요. 그래서 어떻게 해서든 풀기만 해도 아무런 문제 없습니다. 그 자리에서 DP 점화식 찾고 그거 아무나 못 해요.


루팡

문제 푸는 것보다 코딩을 잘하는 게 중요하다 하셨는데 어떤 의미인지 좀 궁금하네요. 남들이 잘 알아보게 짠다는건가요?


김민장

트윗으로 말하기 좀 복잡한데 보통 사람들 보니 릿코드 문제 푸는 것 자체에 집중하더라고요. 그런데 문제해결과정도 잘 의사소통해서 보여줘야하고 지식도 필요하고 그걸 코딩으로 잘 옮기는 것도 필요하죠. 릿코드가 유용은 하지만 이 부분을 다 커버는 못 해요. 깔끔한 코드도 중요하고.

사소한 변수나 자료구조 잡는 것도. 리팩터링도 필요하면 하고. 이런 모든 걸 다 보고 평가하니 풀었다/못 풀었다고 딱 나뉘어지지가 않더군요. 문제해결능력+코딩능력+의사소통+기초전산지식이 조금씩 다 다르죠. 릿코드가 유용하지만 이 모든 걸 커버를 못 하긴 합니다.


루팡

좀 놀랍네요. 구글러들은 dp정도는 다 보고 바로 푸는거 아니었냐며 ㅎㅎㅎ


김민장

실제 코딩에서 DP 쓸 일 거의 없습니다. 외워서 푸는 거 아니면 절대 다수는 못 풉니다. 그런데 문자열 관련 문제는 몇 개 외워서 손해볼 건 없습니다만...



```

<br><br>

> [생각해라. 생각해라. 생각해라.](http://gradschoolstory.net/yoonsup/think/)
>
> **더 세부적으로는** 매우 재미있는 데이터를 얻었는데, 이를 어떻게 하면 더 효과적으로 전달할 수 있을까? 그림을 그린다면, 혹은 표를 그린다면 어떠한 방식으로 표현해야 할까. 실제로 동일한 데이터와 결론을 얻었다고 할지라도 이를 어떻게 의미를 부여하고, 어떻게 표현할지에는 매우 큰 자유도가 존재한다. 좀 과장하자면 이 부분을 잘하는지 못하는지에 따라 논문의 impact factor가 바뀌기도 한다.
>
> <br>
>
> 사람은 동일한 데이터를 보고서도 **다른 생각을 할 수 있다.** ‘대가’ 가 따로 있는 것이 아니다. 다른 사람들도 동일한 데이터와 현상을 보면서도 그 이면에 숨겨진 의미를 파악하고, 의미를 부여할 수 있으면 좋은 과학을 할 수 있다. 좋은 데이터를 얻고서도 충분한 의미부여와 (좋은 의미로) 포장을 제대로 하지 못해서 그 연구 결과가 주목받지 못한다면 인류 전체의 입장에서도 애석한 일이 아닐 수 없다.

<br><br>

> aichupanda @aichupanda
>
> <br>[JTBC 고전적 하루 손열음편 part 2](https://www.youtube.com/watch?v=GJGKYtX94OM)
>
> <br>
>
> [오후 1:16 · 2017년 2월 4일](https://twitter.com/aichupanda/status/827732599825108992)

<br><br>

> [수학자 질 칼라이가 양자컴퓨터가 동작하지 않을 것이라 생각하는 이유](http://newspeppermint.com/2018/03/01/m-quantumcomputer/)
>
> Q: 왜 노이즈를 특정한 값 이하로 낮출 수 없나요?
>
> <br>
>
> A: 많은 연구자들이 노이즈를 그 값 아래로 낮출 수 있다고 생각하며, 양자 컴퓨터를 만드는 일은 단지 기술적인 문제일 뿐이라 생각합니다. 하지만 우리는 근본적 계산 요소(primitive computational devices)의 성능과 관련된 계산 이론이 노이즈 수준의 최소값을 결정한다고 생각합니다. 즉 소형, 혹은 중형 양자 컴퓨터의 노이즈는 그 근본적 계산 성능을 결정하게 됩니다. 이는 매우 근본적인 원칙으로 “양자 우위”를 달성하지 못하게 만들며, 또한 양자 오류 보정 코드 또한 불가능하게 만듭니다.

<br><br>

[Software finds the best way to stick a Mars landing](http://news.mit.edu/2018/software-finds-best-mars-landing-0926)

<br><br>

[Relation and difference between Fourier, Laplace and Z transforms](https://electronics.stackexchange.com/questions/86489/relation-and-difference-between-fourier-laplace-and-z-transforms)

<br><br>

[15 Patents That Changed the World](https://www.popularmechanics.com/technology/design/g20051677/patents-changed-the-world/)

<br><br>

[Why Microsoft Makes $5 to $15 From Every Android Device Sold](https://www.howtogeek.com/183766/why-microsoft-makes-5-to-15-from-every-android-device-sold/)

<br><br>

> [Measuring abstract reasoning in neural networks](https://deepmind.com/blog/measuring-abstract-reasoning/)
>
> <br>
>
> **When required to reason using attribute values ‘interpolated’ between previously seen attribute values,** and also **when applying known abstract relations in unfamiliar combinations,** the models generalised notably well. However, the same network performed much worse **in the ‘extrapolation’ regime, where attribute values in the test set did not lie within the same range as those seen during training.** An example of this occurs for puzzles that contain dark coloured objects during training and light coloured objects during testing. Generalisation performance was also worse when the model was trained to apply a previously seen relation, **such as a progression on the number of shapes, to a new attribute, such as size.**
>
> <br>
>
> Finally, we observed improved generalisation performance when the model was trained to predict **not only the correct answer, but also the ‘reason’ for the answer** (i.e. the particular relations and attributes that should be considered to solve the puzzle). Interestingly, in the neutral split, the model’s accuracy was strongly correlated with **its ability to infer the correct relation underlying the matrix**: when the explanation was right, the model would choose the correct answer 87% of the time, but when its explanation was wrong this performance dropped to only 32%. This suggests that models which achieved better performance when they correctly inferred the abstract concepts underlying the task.
>
> <br>
>
> Recent literature has focussed on the strengths and weaknesses of neural network-based approaches to machine learning problems, often based around their capacity or failure to generalise. Our results show that it might be unhelpful to draw universal conclusions about generalisation: the neural networks we tested performed well in certain regimes of generalisation and very poorly in others. Their success was determined **by a range of factors,** including the architecture of the model used and **whether the model was trained to provide an interpretable “reason” for its answer choices.** In almost all cases, the systems performed poorly when required to extrapolate to inputs beyond their experience, or to deal with entirely unfamiliar attributes; creating a clear focus for future work in this critical, and important area of research.

<br><br>

[Why Tesla is building city-sized batteries](https://youtu.be/8ge3ah1G8ok)

<br><br>

[삼성전자 뛰쳐나와 만든 앱, 찍는 순간 칼로리가 나온다](https://news.joins.com/article/22973973)

<br><br>

[39도씨, “스마트폰만으로 다각도 생방송을”](http://www.bloter.net/archives/321107)

<br><br>

> [99 의지, 그리고 1 운](http://www.thestartupbible.com/2018/09/99-will-and-maybe-1-luck.html) 
>
> [THE MISSION TO BUILD THE ULTIMATE BURGER BOT](https://www.wired.com/story/building-the-ultimate-burger-bot/)   
>
> ...
>
> 얼마 전에 Creator 식당과 이 식당에서 사용하는 로봇 셰프를 만든 Momentum Machines에 대한 기사를 읽었는데, 근래 읽었던 기사 중 가장 인상적이었다. 관심 있는 분은 직접 기사를 읽길 권하는데, 어릴 적부터 뭔가에 깊은 관심이 있는 젊은이가 비전문 분야에 대해서 깊게 독학하고, 차고에서 여러 시행착오를 거치면서 가능성이 많은 사업을 만들고, 투자를 받고, 실제 그가 갖고 있던 비전을 실현하는 전형적인 창업가의 이야기다. 그리스 이민자의 아들 Alex Vardakostas의 부모님은 캘리포니아에서 햄버거 가게를 성공적으로 운영하였고, 알렉스는 부모님 가게에서 어릴 적부터 열심히 알바를 했다. 이 영향 때문인지, 크면서 햄버거를 만드는 로봇 셰프에 대한 고민을 많이 했는데, 주위의 반응이 모두 냉담했기 때문에, 그냥 본인이 직접 한 번 만들어보기로 했다.   
>
> 부모님 집 차고에서 알렉스는 다양한 전문 서적을 직접 읽고, 싸구려 부품을 사서 책에서 읽은 걸 구현해보고, 잘 안되면 다시 관련 서적을 보면서, 본인이 만든 프로토타입을 계속 개선해나갔다. 이런 과정을 반복하면서, 우연한 만남과 기회를 통해서 하드웨어 전문가들을 만날 수 있었고, 이들의 도움으로 계속 로봇셰프를 만들었다. 그리고 2년 후 실제로 작동되는 로봇을 스스로 만들었다. 이제 실제 양산을 하고, 이걸 비즈니스로 만들려면 펀딩이 필요해서 실리콘밸리의 하드웨어 악셀러레이터 중 하나인 Lemnos Labs와 미팅을 했는데, 그 미팅에 대해서 Lemnos의 파트너는 “첫 프로토타입은 싸구려 부품을 여기저기 붙여 만들어서 볼품없었지만, 노트북에서 햄버거 주문 버튼을 누르자, 이 기계가 실제로 작동했고, 로봇이 만든 햄버거가 포장되어 나왔다. 차고에서 한 명이 이걸 만들었다는 건 놀랄만한 공학의 위업이라고 생각했다”라고 기억한다. 그가 5천만 원의 시드펀딩을 했고, 이후 알렉스는 기계를 더욱더 정교하게 만들어서 상용화했고, 그 이후에는 Google Ventures와 Khosla Ventures의 후속 투자를 받았다.   
>
> 대단한 의지의 승리라고 생각한다. 로봇 공학을 전공한 것도 아니고, 공학 박사학위가 있는 창업가도 아니지만, 뭔가 파고 들어가서 만들어야겠다는 의지 하나로 남들이 다 힘들다고 생각하는 수제 햄버거를 만드는 로봇을 혼자 만들었다. 그것도 독학으로. 또 한 가지는, 알렉스는 실현 가능성이 불투명한 그림을 갖고 투자를 받은 후에, 프로토타입을 만든 게 아니다. 없는 살림에 어떻게 해서든지 외부 투자 없이 프로토타입을 만들었고, 이를 통해 가능성을 증명하고, 그 이후에 투자를 받아서 사업을 했다. 실은, 요새 하드웨어 분야에서는 이런 방식으로 비즈니스를 하는 창업가를 찾긴 쉽지 않다. 일단 투자를 받아서 뭔가를 만들려고 하지, 그 전에 본인의 아이디어를 증명하는 경우는 많이 보지 못했다.   
>
> 항상 느끼지만, 역시 사업의 99는 의지인 거 같다. 머리는 의지를 절대로 이기지 못한다. 그리고, 이걸 잘하면, 나머지 1인 운은 그냥 따라서 오는 것 같다.   

<br><br>

> 어엉부엉 @d_ijk_stra   
> 대학원을 절대 가지 말라는 조언을 하는 사람들이 많은 것 같은데, 나는 전산학 한정 + 현재 분위기에서는 설사 인더스트리가 최종 목표라고 해도 대학원을 가는 것이 나쁘지 않은 선택이라고 생각한다. 물론 답은 개인적인 커리어 골이 무엇인지에 따라 정해지겠지만.      
>
> 어엉부엉 @d_ijk_stra   
> 취직하고 나면 칼퇴근을 하고 와도 하루에 자기계발에 쓸 수 있는 시간은 세시간 남짓밖에 안된다. 그나마도 아이가 생기고 나서는 현격하게 줄어들고. 이런 시간을 공부에만 쓸 수 있는 것이 아니라 다른 취미와 운동, 그리고 개인적인 잡무 처리에도 사용해야 하니, 뭉텅이 시간 확보가 힘들다.   
>
> 어엉부엉 @d_ijk_stra   
> 테크니컬한 깊이로 리더쉽을 발휘하는 커리어를 목표하는 주니어 엔지니어라면 개인적인 짜투리 시간만으로는 목표에 도달하기 어렵고, 회사에서 하는 일이 자연스럽게 공부가 되는 길 밖에는 없는데 이런 기회는 없는건 아니지만 미국의 탑 테크 회사들 내에서도 정말 드물다. 당연 경쟁도 심하고.
>
> [오후 11:52 - 2018년 8월 30일](https://twitter.com/d_ijk_stra/status/1035420153683402752)   
>
> 어엉부엉 @d_ijk_stra   
> 그렇기 때문에 대학원에서 향후 두고두고 써먹을 몇몇 주제들에 대해 기술적 깊이를 쌓아 놓으면 남들이 쉽게 따라오기 어려운 경쟁우위가 된다. 당장 주어진 일은 잘 하는데 다음 단계로 나아가기 위한 기술적 깊이를 쌓기 힘든 상황에 있는 사람들이 많이 보여서, 이런 생각을 하게 됐다.   
>
> 어엉부엉 @d_ijk_stra   
> 이런 관점에서는 굳이 박사과정을 끝내야 하는지는 잘 모르겠다. 중퇴하고 인더스트리로 와서 좋은 테크니컬 리더쉽을 발휘하는 사람들이 적잖이 보이기도 하고.   

<br><br>

> leegoonz @leegoonz73
> 셰이더 수업이 이제 한달 째 되는데...
> MSDN 의 셰이더 함수는 모두 다 외우라고 했고 내가 처음 독학 할 때 처럼 프린트 한장에 4 페이지를 작게 프린트 해서 접어서 가지고 다니면서 완전히 다 외울 때 까지 보라고 했는데 ...
> 정말 중국애들 다 그렇고 있음. 시킨대로 잘 하고 있어서 다행.
>
> [오후 12:12 - 2018년 8월 31일](https://twitter.com/leegoonz73/status/1035606352742109185) 

<br><br>

>  [Wireless communication breaks through water-air barrier](http://news.mit.edu/2018/wireless-communication-through-water-air-0822)   
>
> ...
>
> In a paper being presented at this week’s SIGCOMM conference, MIT Media Lab researchers have designed a system that tackles this problem in a novel way. An underwater transmitter directs a sonar signal to the water’s surface, causing tiny vibrations that correspond to the 1s and 0s transmitted. Above the surface, a highly sensitive receiver reads these minute disturbances and decodes the sonar signal.
>
> “Trying to cross the air-water boundary with wireless signals has been an obstacle. Our idea is to transform the obstacle itself into a medium through which to communicate,” says Fadel Adib, an assistant professor in the Media Lab, who is leading this research. He co-authored the paper with his graduate student Francesco Tonolini.
>
> ...
>
> Decoding vibrations   
>
> Today’s technological workarounds to this wireless communication issue suffer from various drawbacks. Buoys, for instance, have been designed to pick up sonar waves, process the data, and shoot radio signals to airborne receivers. But these can drift away and get lost. Many are also required to cover large areas, making them impracticable for, say, submarine-to-surface communications.
>
> TARF includes an underwater acoustic transmitter that sends sonar signals using a standard acoustic speaker. The signals travel as pressure waves of different frequencies corresponding to different data bits. For example, when the transmitter wants to send a 0, it can transmit a wave traveling at 100 hertz; for a 1, it can transmit a 200-hertz wave. When the signal hits the surface, it causes tiny ripples in the water, only a few micrometers in height, corresponding to those frequencies.
>
> To achieve high data rates, the system transmits multiple frequencies at the same time, building on a modulation scheme used in wireless communication, called orthogonal frequency-division multiplexing. This lets the researchers transmit hundreds of bits at once.
>
> Positioned in the air above the transmitter is a new type of extremely-high-frequency radar that processes signals in the millimeter wave spectrum of wireless transmission, between 30 and 300 gigahertz. (That’s the band where the upcoming high-frequency 5G wireless network will operate.)
>
> The radar, which looks like a pair of cones, transmits a radio signal that reflects off the vibrating surface and rebounds back to the radar. Due to the way the signal collides with the surface vibrations, the signal returns with a slightly modulated angle that corresponds exactly to the data bit sent by the sonar signal. A vibration on the water surface representing a 0 bit, for instance, will cause the reflected signal’s angle to vibrate at 100 hertz.
>
> “The radar reflection is going to vary a little bit whenever you have any form of displacement like on the surface of the water,” Adib says. “By picking up these tiny angle changes, we can pick up these variations that correspond to the sonar signal.”
>
> ...
>
> Listening to “the whisper”   
>
> A key challenge was helping the radar detect the water surface. To do so, the researchers employed a technology that detects reflections in an environment and organizes them by distance and power. As water has the most powerful reflection in the new system’s environment, the radar knows the distance to the surface. Once that’s established, it zooms in on the vibrations at that distance, ignoring all other nearby disturbances.
>
> The next major challenge was capturing micrometer waves surrounded by much larger, natural waves. The smallest ocean ripples on calm days, called capillary waves, are only about 2 centimeters tall, but that’s 100,000 times larger than the vibrations. Rougher seas can create waves 1 million times larger. “This interferes with the tiny acoustic vibrations at the water surface,” Adib says. “It’s as if someone’s screaming and you’re trying to hear someone whispering at the same time.”
>
> To solve this, the researchers developed sophisticated signal-processing algorithms. Natural waves occur at about 1 or 2 hertz — or, a wave or two moving over the signal area every second. The sonar vibrations of 100 to 200 hertz, however, are a hundred times faster. Because of this frequency differential, the algorithm zeroes in on the fast-moving waves while ignoring the slower ones.

<br><br>

> [The key to Apple's success? Keeping it simple - from the man who put the 'i' in iPhone](https://www.wired.co.uk/article/simplicity-apple-dna)
>
> ...
>
> Working with Steve was an adventure, but it was also an education. I could see that simplicity had the power to transform a business in the most profound ways.
>
> ...
>
> As Apple continues to grow, what it needs most is a "Simplicity Czar". It became the most valuable company in the world by building products people can fall in love with. When that is the goal, simplicity is one place where there can be no compromise.

<br><br>

[Microfluidics from LEGO bricks](http://news.mit.edu/2018/microfluidics-lego-bricks-0131)

<br><br>

> [[추천] 장병규의 스타트업 한국](https://estimastory.com/2017/12/27/jangstartup/)
>
> **창업자가 투자자와 교류하는데 있어서 유념해야 할 것들**
>
> *-한꺼번에 만나라*
>
> 계획한 투자유치기간에 가급적 여러 투자자들을 동시에 만나는 것이 좋다.
>
> –리드투자자에게 집중하라
>
> 창업자는 해당 투자건을 이끌 수 있는 리드투자자를 확보해야 한다. (많은 투자자들이 다른 투자자의 눈치를 보며 투자한다는 점을 고려하면…)
>
> –대부분 투자자들은 의사 표현을 명확히 하지 않는다
>
> 투자하기 전까지는 창업자의 일은 투자자들 입장에서는 남의 일이다. 무응답이면 무작정 기다리지 말고 무엇이 문제인지 명확히 물어보는 것이 좋다.
>
> –비전은 소수에게만 보인다
>
> 다수의 투자자가 자신의 비전을 외면해도 크게 상관할 필요가 없다. 소수의 투자자만 창업자의 비전을  믿는 경우에도 투자는 성립될 수 있다. 하지만 투자자가 언급하는 합리적 의심을 경청하고 고민하는 자세는 필요하며 그 과정에서 창업자의 비전이 더욱 공고해지고 구체화된다.
>
> –투자자들에게 맞추지 말자
>
> 사업에 대한 고민은 투자자보다 창업자가 깊어야 하므로 창업자가 투자자에게 맞추는 것은 본말전도다.
>
> –투자자와의 관계를 단절하지 말자
>
> 투자자에게 투자유치 이외에도 관계를 유지하는 것이 좋다. 투자자들의 질문에 답하면서 배울 수 있고 또 투자자들의 경험과 네트워크를 통해서 도움을 받을 수 있다.
>
> **스타트업의 3가지 역설적 진실**
>
> 스타트업 성공은 비정형적이다.
>
> 스타트업의 성공방법에는 정답이 없다. 스타트업의 성공을 정형화할 수 없다. 성공한 스타트업의 성공이유를 발견할 수는 있지만 사후적해석일 뿐이다. 모든 스타트업은 자신의 개별스토리가 있으면 저마다의 방식으로 성공한다. 그래서 사업은 남들이 된다고 되는 것도 아니고 남들이 안 된다고 안 되는 것도 아니라는 점을 명심해야 한다.
>
> 스타트업의 평균은 실패다.
>
> 언론에 나오는 성공한 창업자는 극히 일부의 경우다. 평균은 실패라는 것을 잊지말아야 한다. 하지만 좋은 사람들과 치열하게 협업하고 실행하는 과정을 통해서 개인은 역량과 경험은 빠르게 성장할 수 있다.
>
> 스타트업 창업자는 오늘을 살아야 한다.
>
> 스타트업은 지금 주어진 문제를 해결하는데 총력을 기울여야 한다. 가진 것이 없기 때문에 오늘에 몰입하는 힘이 역설적으로 스타트업의 강점이다.

<br><br>

>  [How Four Native Developers Wrote An Electron App](https://githubengineering.com/how-four-native-developers-wrote-an-electron-app/)
>
> <br>
>
> ## Why Rewrite?
>
> First, the elephant in the room: why? Rewrites are rarely a good idea. Why did we decide to walk away from two codebases and rewrite? <br>
>
> From the start, GitHub Desktop for macOS and Windows were two distinct products, each with their own team. We worked in two separate tech stacks using two different skill sets. To maintain parity across the codebases, we had to implement and design the same features twice. If we ever wanted to add Linux support, we’d have to do it all a third time. All this meant we had twice the work, twice the bugs, and far less time to build new features. <br>
>
> As it turns out, building native apps for multiple platforms doesn’t scale.
>
> <br>
>
> ## Why Electron?
>
> This isn’t a new or unique problem. Over the years we explored various ways for evolving the existing applications towards a shared codebase, including [Electron](http://electron.atom.io/), [Xamarin](https://www.xamarin.com/), a shared C++, or in our wildest dreams, Haskell. <br>
>
> We’d already [experimented with web technologies](https://githubengineering.com/cross-platform-ui-in-github-desktop/) to share work. The gravitational pull of the web was too strong to resist. <br>
>
> Beyond our own experience, we had to acknowledge the critical mass accumulating around web technologies. Companies like Google, Microsoft, and Facebook, not to mention GitHub, are investing *incredible* amounts of time, money, and engineering effort in the web as a platform. With Electron, we leverage that investment. <br>

<br><br>

> 석사과정과 박사과정의 차이
>
> |                            | 석사과정                                           | 박사과정                                                     |
> | -------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
> | 목표                       | 박사과정 혹은 산업계에서 필요한 연구 방법론의 습득 | 독립연구자가 되기 위한 연구 능력 습득                        |
> | 기간                       | 2년 이내                                           | 박사가 될 때까지                                             |
> | 학술논문                   | 내면 좋다                                          | 반드시 내야 한다!                                            |
> | 연구 중 어려움에 봉착할 때 | 선배나 교수님이 도와준다.                          | (지도교수의 조언은 있을지언정) 자신의 운명은 자신이 개척한다. |
> | 연구의 전문성              | 사자의 뒷다리를 무는 모기에 대한 연구              | 사자 뒷다리를 무는 모기의 피에 존재하는 기생충의 게놈에서 사자의 면역을 회피하는 데 관여하는 열두 번째 단백질의 기능 |
> | 졸업 이후                  | 취업하거나 박사과정에 들어간다.                    | 포스트닥, 그리고 ...                                         |
>
>  <과학자가 되는 방법>

<br><br>

[What is frequency response and how does it affect my music?](https://www.soundguys.com/frequency-response-explained-16507/)

<br><br>      

 [알고 계신가요? 자바스크립트 핵심 기능, 클로저!](https://ppss.kr/archives/168469)   

```javascript
function outer(){
    var title = 'magictable'
    return function(){
        alert(title)
    }
}

var inner = outer();
inner();

```



<br><br>

[자바스크립트에서 당장 사용해야 할 5가지의 배열 메소드들 (Array)](http://blog.kazikai.net/?p=16)

```javascript
//배열에서 특정값
var isExist = (array.indexOf(“특정값”)!== -1 )


//filter
var arr = [    
  {"name":"apple", "count": 2},    
  {"name":"orange", "count": 5},    
  {"name":"pear", "count": 3},    
  {"name":"orange", "count": 16}
];    
var newArr = arr.filter(function(item){    
  return item.name === "orange";
});  
console.log("Filter results:",newArr);


//forEach
var array = [1,2,3,4,5];
array.forEach( function( v, i ){
  if( v === 3 ){
    console.log( v + ":" + i); // 3:2 가 나온다.
  }
});


//map
var a = [1,2,3,4,5];
// undefined
var b = a.forEach( function(v, i){ console.log(v); return v+1;}});
// [2,3,4,5,6]
var c = a.map( function(v, i){ console.log(v); return v+1;});


//reduce
var a= ["a","b","c","d","e","a","b","a","c","c","c"];
var b = a.reduce(function(x,y){
  console.log("x:", x);
  console.log("y:", y);
  x[y] = ++x[y]|| 1;
  return x;
},{});
console.log(b);

```



<br><br>

> 박치욱 @chiw00k
>
> 피곤한데 쉬지 않으면 몸에 병이 생기지만, 피곤하지도 않은데 쉬면 마음에 병이 생겨요. 피곤하지 않으면 움직이세요. 뭐든 하세요. 그리고 피곤해지면 그때 쉬세요. 정말 그냥 믿고 따라해 보세요.
>
> [오전 1:09 - 2018년 8월 9일 West Lafayette, IN에서](https://twitter.com/chiw00k/status/1027466959422717952)

<br><br>

> 괴골 [개물] @cfr0g
>
> 이해는 다양한 맥락에서 그 정보를 암기해낼 수 있는 상태라고 보면 대충 맞다. 
>
> 사람들이 생각하는 암기란 시험직전에 맥락없이 단기기억만 활용하는 걸 말한다고 봐야한다.
>
> 수학은 오히려 초치기가 어려운 과목이라 위와같은 의미의 암기를 하기가 어렵다.
>
> [오전 4:53 - 2018년 8월 7일](https://twitter.com/cfr0g/status/1026798498178465792)

<br><br>

> 박대기 @waitingpark
>
> 과학고 입학 후 수학 0점을 받았습니다. 친구를 화장실에서 만나서 충고를 들었습니다. "수학은 암기 과목이야.  풀이의 요령을 외우는 거지" 깨달음을 얻고 수학을 잘 하게 됐습니다. 충고해준 친구는 나중에 수능 수석을 했죠.
>
> [오후 5:05 - 2018년 8월 6일](https://twitter.com/waitingpark/status/1026620413877481472)



<br><br>

[초심자를 위한 Github 협업](http://www.realhanbit.co.kr/books/125)   

<br><br>

>  [멀티플레이어, 제네럴리스트와 스페셜리스트](https://cfr0g.wordpress.com/2018/03/23/%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4-%EC%A0%9C%EB%84%A4%EB%9F%B4%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%8A%A4%ED%8E%98%EC%85%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/) 
>
> 
>
> 이 타이밍 및 학습곡선의 차이, 실제 현업/시장에서의 수요공급차이가 사뭇 다르기 때문에, 둘 다 부족한 경우가 비일비재하다. 심지어 사람이 있어도 요구능력에 못미치거나, 오버스펙이거나 하는 경우가 많다(예를 들어 스페셜리스트가 너무 고수면, 닭잡는데 소잡는 칼을 쓰는 꼴이 되는 경우도 많다). 누가 어느 시점에 어느 역할을 할지에 대한 전략은, 조직이나 조직이 처한 문제, 상황따라 다르니 개인 차원에서 어떤 커리어를 밟는게 늘 더 좋다고 말하긴 어렵다.
>
> 다만 둘다 고수로 가는 길목 어딘가에는 반드시 반대편의 시각과 기술을 완전히는 아니더라도 배울 필요가 있다. 그렇지 않고서는 한단계 업그레이드하기 어렵다. 자신의 기술이 제너럴리스트의 관점에서 어떤 부분을 담당 하는지 모르면, 남이 만든 기술을 배워서 써먹는 스페셜리스트까지가 한계다. 스페셜리스트들이 정확하게 무엇을 하고 있고, 근 미래에 무엇을 할 수 있을지 예측 못하는 제너럴리스트은 당장 커뮤니케이션에 문제가 생길 뿐 아니라 모든 요소들 사이에 시너지를 만들어내는 능력이 떨어질 수 밖에 없다. 개인 발전 측면에서 볼때 두 역할을 무자르듯 양단해서 생각하면 발전이 어렵다. 순서의 문제지 결국에는 둘 다 잘해야하는 시점이 오긴 온다.

<br><br>

> 하이컨셉 @Haeundo
>
> 지금 내가 해야 할 일은 1 목록을 작성하라. 2 우선순위를 정하라. 3 실행에 옮겨라.  이렇게 간단한 일이 참 쉽지 않네요...
>
> [오후 7:29 - 2018년 7월 28일](https://twitter.com/Haeundo/status/1023394949188841472)
>

<br><br>

> Taeho Kim @xissy
>
> 원래 미국에 창업을 하러 온거였지 이민을 생각하고 온건 아니어서 언젠가 때가 되면 돌아간다는 마음이었는데 그러다보니 이러지도 저러지도 못하는 경우가 있었다. 이번 한국 방문 후 마음을 정했다.
>
> [오후 4:52 - 2018년 7월 21일](https://twitter.com/xissy/status/1020818767348035584)
>
> Taeho Kim @xissy
>
> 선배, 친구, 후배들을 막론하고 개발자로서의 진로 고민이 1이라면 어디에 집을 사서 시세차익을 낼지 고민하는게 10이다. 더 발전하기 위한 개발자 롤모델은 찾아볼 수 없으며 IT는 3D업종으로 받아들여진다. 열심히하고 잘하는 개발자와 그저그런 개발자의 연봉이 거의 같다. 원래 그렇단다.
>
> Taeho Kim @xissy
>
> 엔지니어의 역할은 한정되어 있으며 그 환경에 젖어 자신도 모르게 자신의 한계를 제한한다. 성실히 실력을 갈고 닦아 성과를 내고 인정 받아 몸값을 올리는 길이 거의 막혀 있으며 그러니 다들 일확천금을 노린다. 시장이 작아서 그런가. 각종 규제로 기술 혁신이 힘들어서 그런가.
>
> Taeho Kim @xissy
>
> 엔지니어를 프로 스포츠 선수처럼 대우하는 것이 가능하려면 1. 기술 기반 혁신 기업에 대한 사회적 인식이 팬덤 처럼 일어나고, 2. 완성된 엔지니어가 만들어내는 가치를 알아보고 이를 육성하는 토대 마련, 3. 엔지니어들의 비지니스 임팩트 기반 사고와 실천 능력 배양이 먼저 필요하다.
>
> Taeho Kim @xissy
>
> 한 마디로, 자신의 기술을 갈고 닦는 것은 물론이고 이를 적절한 곳에 찔러 수익화 시키고 사회적 영향력을 만들어 내는 것까지 엔지니어의 고민에 속해야 한다.
>
> Taeho Kim @xissy
>
> 이런 주체적 마인드 없이 개발자의 길을 가다보면 길을 잃기 십상이다. 많은 경영자들이 근시안적인 개발자들을 좋아한다. 싸고 하라는거만 하니까. 나이 먹고 하라는거 조금 빨리 하는 정도로는 경쟁력 없다. 비지니스의 큰 짐을 함께 짊어지고 갈 수 있을 때 큰 경쟁력과 임팩트를 만들 수 있다.
>
> Taeho Kim @xissy
>
> 업무 자동화와 정보 투명화가 개발자의 무기다. 기득권이 독점하던 정보를 사용자들에게 투명하게 보여주고 더 나은 선택을 하도록 유도한다. 이 플로우를 간소화, 자동화 하여 다시 데이터로 쌓고 정제하는 것을 반복한다. 이게 지속가능한 기술 기반 혁신 및 가치 생성의 키다.
>
> Taeho Kim @xissy 
>
> 격변하는 세상에서 이 타이밍에 개발자로 살고 있다는 것 자체가 혜택이고 기회다. 나중에 돌아보면 너무 안타까울.

<br>

> 여기서도 핵심은 말로 할 줄 알아야 들린다. - 김교포 

<br>

> redacted @29979245oo
>
> https://docs.google.com/presentation/d/13axrCeVifUXpwArnzqHrBKMqMH3n4-Bsp21H0CF47bQ/edit#slide=id.g3e0d9a72d1_1_168 … 왜 인터뷰 준비할 때 자꾸만 다이나믹 프로그래밍에 시간을 투자 하는지 참 안타깝다. Brute-force로 풀어도 문제 없습니다. 거대한 트랩 같다. DP 공부하느라 정작 중요한 코딩 실력 놓치고 면접은 떨어집니다.
>
> [오후 4:30 - 2018년 7월 20일](https://twitter.com/29979245oo/status/1020450984533766144)

<br><br>

> 상일 @sioum
>
> 수학과 대학원에서의 성공을 예측할 수 있는가? 
> 캘리포니아 남부 대학들 조사해보니 의외로 GRE가 상관관계가 높았으며 특히 GRE verbal 점수가 상관관계가 높았고 학점은 큰 상관이 없었다고
> "Admission predictors for success in a mathematics graduate program"
> https://arxiv.org/abs/1803.00595 
>
> <img src="https://pbs.twimg.com/media/DiL8S6RUEAE8lRo.jpg">
>
> [오후 5:31 - 2018년 7월 15일](https://twitter.com/sioum/status/1018654359414923264)

<br>

[How does a compiler, interpreter, and CPU work?](https://www.youtube.com/watch?v=OVTu4XcmnwE)

<br>

[Processor Design - RISC,CISC & ROPS](https://www.i-programmer.info/babbages-bag/392-inside-the-processor.html)

<br>

[A Beginner’s Guide to RISC and CISC Architectures](https://medium.com/@csoham358/a-beginners-guide-to-risc-and-cisc-architectures-fc9af424db3b)

<br>

[RISC vs. CISC](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/)

<br>

[승강기서 전화 안 끊기는 간편 방법 나오나?](http://www.astronomer.rocks/news/articleView.html?idxno=85883)

> UNIST 전기전자컴퓨터공학부의 변영재 교수팀은 '평면에 무늬를 새겨 넣는 것만으로 금속 통신이 가능하다'는 사실을 발견했습니다. 금속에 전파를 통과시키는 '전자기 유도 투과(Electromagnetically induced transparency, EIT)'의 새로운 방식으로 주목을 받고 있어요.
>
>  
>
> 전자기 유도 투과는 물질을 이루는 원자에 전파를 포함한 빛을 쏘거나 다른 방식으로 영향을 줘서, 특정 파장을 통과시키는 걸 말합니다. 그 파장에만 물질이 투명해지도록 만드는 것이죠. 일반적으로 금속은 전파를 흡수하거나 반사시키기 때문에 전파를 못 통과시키지만, 전자기 유도 투과 기술을 쓰면 특정한 파장은 통과시킬 수 있습니다.  
>
> 
>
> 그런데 금속 통신을 위해 전자기 유도 투과 기술을 쓰기는 어려웠습니다. 이 기술이 제대로 구현되려면 극저온 환경이거나 빛의 세기를 조절하는 고강도 광학 펌프 같은 정교한 장치가 필요했기 때문인데요.  
>
> 
>
> 변영재 교수팀은 극저온 환경이나 복잡한 장치 없이도 전자기 유도 투과가 가능한 방법을 찾아냈습니다. 절연체 위에 '직사각형 속 사인곡선이 반복되는 무늬'를 새기자 특정 주파수의 전파가 금속을 통과하는 걸 발견한 겁니다. 무늬의 크기나 배치를 바꾸면 통과하는 주파수 범위도 조절할 수 있었다고 합니다.

<br><br>

> 어엉부엉 @d_ijk_stra
>
> 고급 영어를 구사하는 책을 읽을 때에는 정신줄을 잠깐 놓으면 단어 하나하나만 들여다 보거나 소리를 마음 속으로 읽고만 있어서, 막상 페이지를 다 넘기고 나면 머리 속에 남는게 아무것도 없을 때가 많다. 그래서 책이 괜찮다 싶으면 2회독을 하면서 중고등학교 국어시간 때처럼 책을 읽는다.
>
> [오전 5:09 - 2018년 6월 18일](https://twitter.com/d_ijk_stra/status/1008683109154353153)
>
> 어엉부엉@d_ijk_stra
>
> 구체적으로는 문단별로 중심 문장을 찾아서 밑줄을 치고, 섹션별로 내용을 요약해 본다. 그러면 비로소 내용을 이해하려고 하며 적극적으로 읽게 되는 것 같다. 중고등학교 때 의식적으로 국어 공부를 했던 것처럼, 비슷한 노력을 영어에도 기울여야 하나보다.
>
> <img src="https://pbs.twimg.com/media/Df-QyogUcAYppJc.jpg">

<br>

<br>

> redacted @29979245oo
>
> 그리고 제발 다이나믹 프로그래밍 이런 거에 시간 허비 하지 말라고. 왜 여기에 그렇게 시간 쓰는지 너무 안타깝다. DP 문제 나오면 그냥 브루트 포스로 풀어요. 그 담에 메모이제이션해서 조금만 최적화 해도 됨. 그런데 이보다 코딩을 잘 해야 함. 대부분은 잘 못합니다. 누가 지적 안 하면 모름.
>
> [오전 11:12 - 2018년 4월 6일](https://twitter.com/29979245oo/status/982320268784885760)

<br>

[[반도체 용어 사전] 핀펫(FinFET= Fin Field Effect Transistor) 공정](http://www.samsungsemiconstory.com/1353)

> 트랜지스터는 게이트에 전압이 가해지면 채널을 통해 'Source'에서 'Drain'으로 전류가 흐르며 동작하게 된다. 이때 게이트와 채널과의 접점이 클수록 효율이 높아지는데, 핀펫 공정은 핀(Fin) 모양의 3D 구조를 적용, 접점 면적을 키워 반도체 성능 향상 및 누설 전류를 줄였다.

<br>

> 안녕하세요 개골님. 저는 전자공학 수업 몇개를 들은 적이 있지만 대학원 문턱도 못 가본 사람입니다. 제가 우연히 올해 전자공학 분야에서 유명한 연구 세 가지를 접했는데요. 1) https://bit.ly/2HZyzRm 2) https://bit.ly/2IiCFIc 3) https://bit.ly/2JTQUkd 외람된 이야기지만 제가 이해햐기로는 작은 (어쩌면 간단한) 개선인것 같은데요. 원래 논문이라는 것이 이처럼 작은 개선의 반복인 것인지요? 
>
> <br>
>
> [개골](https://ask.fm/cfr0g/answers/148254105578)
>
> <br>
>
> 네. 거의 대부분의 논문은 작은 개선들이죠

<br>

[Towards Battery-Free HD Video Streaming](http://batteryfreevideo.cs.washington.edu/)

> We present a novel architecture that enables HD video streaming from a low-power, wearable camera to a nearby mobile device. To achieve this, we present an "analog" video backscatter technique that feeds analog pixels from the photo-diodes directly to the backscatter hardware, thereby eliminating power-consuming hardware components, such as ADCs and codecs. 

<br>

[Self-driving cars for country roads](http://news.mit.edu/2018/self-driving-cars-for-country-roads-mit-csail-0507)

> In contrast, MapLite uses sensors for all aspects of navigation, relying on GPS data only to obtain a rough estimate of the car’s location. The system first sets both a final destination and what researchers call a “local navigation goal,” which has to be within view of the car. Its perception sensors then generate a path to get to that point, using LIDAR to estimate the location of the road’s edges. MapLite can do this without physical road markings by making basic assumptions about how the road will be relatively more flat than the surrounding areas.

<br>

[Depth-sensing imaging system can peer through fog](http://news.mit.edu/2018/depth-sensing-imaging-system-can-peer-through-fog-0321)

> Crucially, the system calculates a different gamma distribution for each of the 1,024 pixels in the sensor. That’s why it’s able to handle the variations in fog density that foiled earlier systems: It can deal with circumstances in which each pixel sees a different type of fog.

<br>

<br>

> Seongjae Lee @seongjaelee
>
> 페북분이랑 이야기하다 개소름이었던게 페북은 php 뜯어고쳐서 쓰고 있다는 건 알았는데 인스타그램은 파이썬 쟝고로 짜여있다고... 진짜 php/python으로도 월드스케일 커버 가능하다는 산 증인...
>
> [오후 10:57 - 2018년 6월 13일](https://twitter.com/seongjaelee/status/1007139975387742208)

<br>

> [-5-](https://leenotes1.blogspot.com/2018/06/180610.html) 
>
> <br>
>
> 어릴적 다니던 모 학원의 선생님이 강의 중에 "열심히 했는데도 성적이 나오지 않는다는 것은, 열심히 하지 않았거나 시험에 나오지 않는 것을 열심히 했다는 뜻이다" 라고 하셨던 것을 아직까지도 기억한다. 아마 그 말에 꽤 공감을 하고 있었기 때문에 아직까지 기억을 하는 것 같다. 과연 열심히 하고 있는 것인지, 필요한 부분을 열심히 하고 있는 것인지를 자문하는 과정은 늘 필요하다고 본다. 그리고 만약 중요한 것에 열중하고 있음이 분명함에도 성과가 나오지 않는다면, 거기서 더 필요한 것은 시간이라고 생각한다. 시간이 무제한적이지 않다는 점이 문제이지만, 그래도 더 해보는 것 외에 다른 방법은 없다.

<br>

[PAPERS WE LOVE](https://github.com/papers-we-love/papers-we-love)

<br>

[Disable tailspind and spindump to Speed Up your Mac](https://www.macobserver.com/tips/how-to/disable-tailspind-spindump-macos-cpu-speed/)

<br>

[How I Became a Better Programmer](https://jlongster.com/How-I-Became-Better-Programmer)

<br>

[[번역] 나는 어떻게 더 나은 프로그래머가 되었는가](https://medium.com/@rinae/%EB%B2%88%EC%97%AD-%EB%82%98%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8D%94-%EB%82%98%EC%9D%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EA%B0%80-%EB%90%98%EC%97%88%EB%8A%94%EA%B0%80-b84c45d8bf98)

> 하지만 방금 말씀드린 유형의 사람들을 맹목적으로 따르면 안됩니다. 트위터에서 보면 엄청나보이는 사람도 **실제로 일하는 모습을 보면 우리가 일하는 모습과 그리 다르지 않습니다.** 모든 수단과 방법을 가리지 않고 작동하는 코드를 쓰려 합니다(Hacks everywhere). 우리는 그저 더 나은 방법을 위해 계속 실험하고 있는겁니다.

> 제 생각에 가장 좋은 아이디어들 중 일부는 비교적 새로운 프로그래머들로부터 나옵니다. 그 사람들은 기존 기술의 발전을 지켜보면서도 이미 틀에 박힌 의견을 보지 않는 사람들인 경우가 많습니다.

> 매일 등장하는 대부분의 새로운 라이브러리 등은 그저 기존에 있던 같은 아이디어의 재탕입니다. **진정 혁명적인 물건은 몇 년에 한번씩 나타납니다.** 이 내용에 대한 좋은 발표가 있습니다. 제목은 [해먹 주도 개발(Hammock Driven Development)](https://youtu.be/f84n5oFoZBc)입니다.

> 그렇다면 “자잘한 게” 뭘까요? 여러분이 생각하시기 나름입니다만, 제가 자잘한 것이라 생각하는 몇 가지 예를 드리겠습니다. 언어의 문법, 라이브러리의 API, 빌드 도구의 설정 방법, ES7 이후의 자바스크립트 문법 등을 익히는 일은 **컴파일러의 동작원리 등을 익히는 일에 비교하면** 여러분을 더 좋은 개발자로 만들어주지 않습니다. 기존에 있던 아이디어를 새로운 API 로 구현해 놓은 수준의 라이브러리를 채택해서 쓰는 일은 그닥 도움이 되지 않습니다. 물론 위에 서술한 모든 것들이 도움이 되긴 합니다만, 심층적인 내용에 시간을 **더**투자하길 권합니다. 그러면 몇년 뒤에 큰 도움이 됩니다.
>
> 여러분께 질문을 드려봅니다. 대부분의 시간을 코드가 “깔끔하게” 보이는데 쓰고 있나요? 그렇다면 그러지 마시길 권합니다. 어차피 여러분의 코드는 여러 번에 걸쳐 변하게 되어있습니다. 해결하고자 하는 문제 및 추상화 계층에 많은 시간과 노력을 들이는게 더 낫습니다. 모든 문제가 정리되었다면 약간의 시간을 들여서 코드를 정리하는 작업을 하면 됩니다. (DRY 원칙에 위배될 수 있습니다만, **일단 너무 걱정하지 마시고 마음 내키는대로 중복 코드를 작성해보세요**)

> 어떤 아이디어가 떠올라서 바로 작업에 착수하고 싶어질 떄가 있습니다. 하지만 기존에 다른 사람들이 그 문제를 어떻게 해결했는지 간단히라도 살펴보기 전 까지는 무작정 시작하지 마세요. **특정 주제를 며칠 정도 조사해보는 버릇은 언제나 문제를 해결하는 방법을 송두리째 바꿔줍니다.**
>
> 논문을 읽는 방법을 배우는 것도 좋습니다. 저는 수학적 의미론/조작적 의미론 등의 용어는 하나도 몰라서 읽을 수 없는 논문이 많습니다. 하지만 수학 용어 대신 코드로 이루어진 논문도 많으며 읽는 것도 그리 어렵지 않습니다. 과거 30 년간 *엄청난*양의 지식이 논문을 통해 축적되었습니다. **여기서 필요한 지식을 잘 추출하는 능력만 기르면 금세 지식을 선도하는 사람(thought-leader)이 될 수 있습니다.**
>
> [Prettier](https://github.com/prettier/prettier)는 위에 설명드린 팁의 완벽한 예시입니다. 저는 제가 뭘 하고 싶은지는 알겠는데 구현하는 방법은 전혀 떠올리지 못했습니다. 조사를 좀 해보니 [이런 논문](http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf)을 발견했고, 며칠 뒤 뭘 해야하는지 정확히 파악할 수 있었습니다. 그러고 나니 기본적인 작업은 1 주일만에 끝났습니다. 만약 사전에 조사해보지 않았다면 훨씬 오래 걸렸을겁니다.
>
> 혹시 논문을 찾아보고 싶으시다면 [Papers We Love](https://github.com/papers-we-love/papers-we-love)라는 훌륭한 Github 저장소부터 살펴보시길 바랍니다.

>무언가를 익히는데 직접 경험하는 것 보다 더 나은 수단은 없습니다. 모든 사람들이 뛰어들 수 있진 않지만, 만약 시간이 있다면 큰 프로젝트를 맡아보세요. **굳이 끝까지 마칠 필요는 없습니다. 그냥 컴파일러 작성을 해보는데 머리를 싸매다 보면 몇 주만에 아주 많은 것을 배울 수 있습니다.**
>
>저는 솔직히 복잡한 문제를 해결하고 싶은데 하나도 모르는 기분이 싫습니다. (익숙지 않아서) 불편합니다. 문제 해결의 실마리라도 얻으려면 많은 양의 조사를 하고 배워야 한다는 것도 압니다. 하지만 이 모든 과정을 거치고 나면 저는 언제나 더 나은 프로그래머가 됩니다.

>몇 가지 추천할만한 방법들을 리스트로 추려 보았습니다. 이 모든 방법들은 제 프로그래머 커리어에 커다란 영향을 주었습니다. 대부분은 지금도 다양한 형태로 도움이 되고 있으며 새로운 아이디어를 깊게 분석하는데 도움이 됩니다. **좋은 프로그래머가 되기 위해 아래 모든 일을 다 할 필요는 없습니다.**그리고 분명 여러분의 성장을 도울 수 있는 다른 방법들이 있습니다. 그저 저에게 도움이 되었던 방법을 말씀드려 보겠습니다.
>
>- **C 배우기**- 아직 해보신 적 없다면 기본만 살펴보시기 바랍니다. 왜 모두들 C 를 가지고 불평하는지 이해할만한 가치는 있다고 생각합니다.
>- **컴파일러 작성해보기**- 아마 익숙하지 않은 일을 하면서 배우는 방법 중 최고봉일겁니다. [Super Tiny Compiler](https://github.com/thejameskyle/the-super-tiny-compiler)를 살펴보세요.
>- **매크로를 배우기**- Scheme, Lisp, Clojure(Script)를 살펴보세요. 매크로는 코드를 보는 방법을 크게 바꾸어줍니다.
>- **SICP**- [SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html)는 아주 오래된 책이지만 여전히 유용한 정보를 담고 있는 책이라고 생각합니다. (그렇게 생각하지 않는 사람들도 있습니다) 이 책은 프로그래밍 지식이 아주 얕은 독자를 대상으로 [meta-circular evaluator](https://en.m.wikipedia.org/wiki/Meta-circular_evaluator)와 컴파일러를 구현하는 방법을 처음부터 끝까지 알려줍니다. 제가 재밌게 읽으면서 컴파일러를 더 깊이 알아볼 수 있던 책은 [Lisp In Small Pieces](https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668)였습니다.
>- **Continuation 을 이해하기**- [Continuation](https://en.wikipedia.org/wiki/Continuation)은 저수준의 제어 흐름 원리입니다. Scheme 은 이를 유일하게 구현한 언어이며, 실무에 사용할 일은 전혀 없을테지만 제어 흐름을 생각하는 방식을 바꿔줄겁니다. 저는 이 내용을 설명하기 위해 [블로그 포스트](http://jlongster.com/Whats-in-a-Continuation)도 작성했습니다.
>- **아무거나 새로운 프로그래밍 언어 배우기**- 무엇을 하시던지 다른 언어를 배우시는게 좋습니다. 제가 추천하는 언어는 Clojure, Rust, Elm, OCaml/Reason, Go, Scheme 입니다. 이 모든 언어들은 각자 고유한 기능이 있으며 그 기능을 통해 새로운 사고방식을 배우도록 만들어줍니다.

<br>

[Hedy Lamarr – the 1940s ‘bombshell’ who helped invent wifi](https://www.theguardian.com/film/2018/mar/08/hedy-lamarr-1940s-bombshell-helped-invent-wifi-missile)

<br><br>

> 안희종  @heejongahn
>
> 중학생 땐 나름 중등부 화학 올림피아드 금상까지 타고, 과학고 가서도 화학 전공하고, 심지어는 잠깐이지만 대학에서도 화학과였던 때가 있는데 지금은 너무 놀라울 정도로 전부 까먹었다. 친구들 만나서 종종 얘기하다 보면 중학교 내용도 전혀 기억 못하는 나에게 좀 놀란다. 신기하고 좀 슬프기도.
>
> [오전 7:18 - 2018년 5월 22일](https://twitter.com/heejongahn/status/998931062762844161)

유능한 분도 시간이 지나면 잊기 마련인데, 나같은 사람이 망각하는 것은 너무나 당연한 일.

<br>

[Relation and difference between Fourier, Laplace and Z transforms](https://electronics.stackexchange.com/questions/86489/relation-and-difference-between-fourier-laplace-and-z-transforms)

<br>

[Shuji Nakamura - Facts](https://www.nobelprize.org/nobel_prizes/physics/laureates/2014/nakamura-facts.html)

<br>

> 朴聖國, Shawn @sungkkshawnpark
>
> 앞으로 게임을 이해하고 만들 사람들은 한국어에 빚질 것이 없거나 적다. 언어 면에서 게임을 이해하거나 만드는데 필요한 원자료는 한국어로 작성된 것이 거의 없다. 프로그래머만 해도 영어 문서를 독해하는 능력이 없다면 생산성은 끔찍하게 낮다. 소규모 게임을 만드는 커뮤니티는 멸종 상태이다.
>
> [오전 6:53 - 2018년 4월 25일](https://twitter.com/sungkkshawnpark/status/989140354250162177)

<br>

<img src="https://dzone.com/storage/temp/5464204-enterprise-vs-startup-journey-to-cloud.png">

<br>

[Eigenvectors and Eigenvalues](http://setosa.io/ev/eigenvectors-and-eigenvalues/)

<br>

[훌륭한 소프트웨어 엔지니어란? 답: 카멜레온 개발자](https://medium.com/@kpak/%ED%9B%8C%EB%A5%AD%ED%95%9C-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%9E%80-%EB%8B%B5-%EC%B9%B4%EB%A9%9C%EB%A0%88%EC%98%A8-%EA%B0%9C%EB%B0%9C%EC%9E%90-b73502a63016)

> 탁월한 개발자는 주어진 문제에 최상의 해결책을 파악하고 그 해결책이 커뮤니케이션이든 개발이든 리더십이든 단시간내에 부족한 부분은 빨리 배우고 익히며 자신을 변화시켜 그 상황에 최적화된 모습을 갖춘다. 이 글의 제목처럼 카멜레온같은 개발자가 되야 한다.

> 과거에 내가 약간 복잡한 알고리듬을 만들어서 실리콘밸리에 있는 개발자들에게 Swift 코드로 구현하라고 한적이 있다. 나름 복잡하고 테스트를 많이 해야하는 것이라서 대충 3주의 스케쥴로 잡았는데 2주만에 끝내서 상당히 기뻐했다. 다음에 같은 알고리듬을 중국에 있는 팀에게 Java 로 구현하라고 했는데 딱 3일 걸렸다. 나는 미국의 동부, 서부, 인도, 중국, 파키스탄, 한국등의 개발자들과 일을 해봤는데 실리콘밸리나 타지역이나 평균개발자들의 능력은 전혀 차이가 없다. 그런데 일반적인 시각은 실리콘밸리의 개발자들이 보다 더 나은 개발자들이라는 인식이 있다. 왜 그럴까? 실리콘밸리가 타지역과 가장 큰 차이점은 극소수의 천재들이 있다는 것이다. 그런 천재들이 구글같은 회사도 만들고 AWS 같은 기술들을 만들어서 어마어마한 마켓을 만들어 준다. 그리고 그 조직에 속해있는 일반 개발자들은 거기에 그냥 묻혀가는 면이 있다.

<br>

[BUILD YOUR OWN X](https://github.com/danistefanovic/build-your-own-x)

> "What I cannot create, I do not understand." - Richard Feynman

<img src="https://github.com/danistefanovic/build-your-own-x/raw/master/feynman.png">

<br>

[Welcome to Project Soli](https://www.youtube.com/watch?v=0QNiZfSsPc0&feature=youtu.be)

<br>

[당신과 당신의 연구](http://ropas.snu.ac.kr/~kwang/quote/hamming.html)

> 내가 벨 연구소로 올 때, 내가 소속된 연구부서에서는 연구결과를 왕성히 쏟아내고 있었습니다. 보드(Bode)가 당시 부서장이었습니다. 샤논(Shannon)이 그 부서에 있었고, 그 외의 사람들이 있었습니다. 나는 계속 질문들을 했지요, "왜?", "그 차이가 무엇일까?" 그리고는 인물서, 자서전을 읽었고, 사람들에게 물어봤습니다: "어떻게 이 일을 하게 되었나요?" 차이점들이 뭔지를 알아내려고 노렸했습니다. 이 이야기가 바로 그것에 대한 이야기입니다.

<br>

> 예를 들어, 빌 팬(Bill Pfann)이라는 친구가 있었습니다. 존 멜팅(zone melting)이라는 분야를 일군 사람입니다. 그가 어느날 내 연구실로 왔었습니다. 그가 원하는 바에 대해서 희미하게 아이디어가 있었고 어떤 방정식이 있었습니다. 이 사람이 수학은 잘 모른 다는 게 내게 분명했지요 그리고 그는 그렇게 썩 명료하게 말하는 모습이 아니었습니다. 그가 가지고 온 문제가 재미있어 보여서 집에 가지고 와서 약간 살펴보고 작업해 봤지요. 최종적으로 그에게 어떻게 컴퓨터를 돌리면 그가 바라는 방식의 답을 얻을 수 있는 지를 보여 주었습니다. 그에게 계산하는 능력을 전수해 준 것이지요. 그는 계속 진행했고요. 그의 부서에서는 거의 알아주지도 않는 것이었습니다. 그런데, 결국에는 그는 그 분야의 모든 상을 휩쓸었습니다. 한번 시작이 잘 되니까, 그의 소극적인 부끄럼, 이상스러움, 명료하지 못함 등은 모두 떨구어지고 여러방면으로 굉장이 많은 성과를 내게 되었습니다. 확실히 엄청나게 명료해지기도 했고요.

<br>

> 비슷하게, 또 다른 사람의 예가 있습니다. 여기 청중중에 없다고 믿는데요. 클럭스톤(Clogston)이라는 친구입니다. 내가 그를 만난건 내가 존 피어스(John Pierce)의 그룹에서 어떤 문제를 풀고 있던 때 였습니다. 나는 그가 별볼일 없다고 생각했어요. 그와 같이 학교를 다녔던 친구들에게 물어봤지요. "대학원때도 제는 저랬냐?" 그들 대답은 "예스"였지요. 나는 아마도 그 친구를 해고했을 겁니다. 그러나 피어스(John Pierce)는 현명하게도 그를 계속 멤버로 가지고 있었습니다. 클럭스턴은 결국에는 "클럭스턴 케이블"이라는 것을 해 냅니다. 그 이후로는 꾸준히 좋은 아이디어들이 흘려 나왔지요. 하나의 성공이 그에게 자신감과 용기를 가져다 준 겁니다.

<br>

> 성공적인 과학자의 특징중 하나는 용기를 가지고 있다는 것입니다. 용기가 붇돋워지면 중요한 문제들을 풀 수 있다고 믿게되고 그러면 해내게 됩니다. 못할 거라고 생각하면 거의 분명히 못하게 됩니다. 용기는 샤논(Shannon)이 엄청 가지고 있던 특징들 중의 하나지요. 그의 주요 이론을 상기하면 됩니다. 그것에 대한 이야기입니다. 코딩의 방법을 만들고 싶어합니다 그런데 어떻게 해야할 지를 모릅니다 그래서 무작위로 코딩합니다. 그리고 벽에 부딛칩니다. 그리고는 불가능한 질문을 합니다, "무작위 코드들이 평균적으로 하는 일이 뭘까?" 그리고는 그는 증명합니다. 평균 코드는 아무렇게해도 좋은 코드다. 그렇다면, 그러므로 좋은 코드는 적어도 하나는 존재한다. 이런 식의 생각들을 감히 할 수 있다는 것이 무한대의 용기를 가지지 않고서는 누가 할 수 있는 생각이겠어요? 이게 바로 위대한 과학자들의 성격입니다. 용기를 가지고 있지요. 믿기지 않는 상황에서도 계속 갑니다; 생각하고 생각하고 계속 생각합니다.

<br>

> 유명해지면 조그만 문제를 연구하는 것이 어려워집니다. 이게 바로 샤논(Shannon)을 잡아먹은 거지요. 정보 이론 이후에 다음으로 또 한 껀 뭘 할까? 위대한 과학자들이 이러한 실수를 합니다. 시작을 작게 하지 못하게 됩니다. 미래에 엄청난 아름드리 참나무로 자라게 될 아주 작은 도토리를 심지 못하는 것이지요. 처음부터 커다란 것을 곧바로 하려고 듭니다. 그런데 이것은 일이 되는 방식이 아니랍니다. 이게 바로 우리가 일찌감치 인정을 받으면 그 이후로는 아무 성과가 없게되고마는 이유이기도 하지요. 
>
> <br>
>
> When you are famous it is hard to work on small problems. This is what did Shannon in. After information theory, what do you do for an encore? The great scientists often make this error. They fail to continue to plant the little acorns from which the mighty oak trees grow. They try to get the big thing right off. And that isn't the way things go. So that is another reason why you find that when you get early recognition it seems to sterilize you. 
>
> You and Your Research

<br>

> 이 이야기때문에, 순서가 뒤바뀐 듯 하지만, 연구하는 환경에 대한 이야기를 하게되겠네요. 대부분의 사람들이 생각하는 최고의 연구환경은 최고의 연구환경이 아닙니다. 분명히 아닙니다. 왜냐하면 자주 있는 일인데, 사람들이 연구 성과가 제일 좋은 때는 연구환경이 나빴을 때입니다. 캠브리지 물리학 연구실(Cambridge Physical Laboratories)이 좋았던 시절 중 하나는 연구실들이 그야말로 판자집이었을 때 였습니다. 그 때 그들은 지금까지 중 최고의 물리학 성과를 일구어냈지요.

<br>

> 보드(Bode)가 말하던 것은 이겁니다. "지식과 연구 생산성은 복리의 이자와 같은 거다." 거의 같은 능력의 두 사람이 있다고 합시다. 한 사람은 다른 사람보다 10% 더 공부한다고 해요. 그러면 그 사람은 다른 사람보다 2배의 더 연구결과를 만들어 낼 겁니다. 더 알면 알 수록 더 많이 배우게 됩니다; 더 많이 배울 수록 더 많은 일을 할 수 있게되고, 더 많이 일을 할 수 있게되면 기회는 더 많아 집니다. 복리 이자와 아주 비슷하지요. 이자율을 말 하고 싶지는 않고, 아뭏튼 굉장히 높은 이자률이지요. 완전히 같은 능력의 두 사람이 있다고 하면, 매일 생각을 1시간 더 하게되면 평생 엄청나게 더 많은 연구결과를 낼 겁니다. 나는 보드(Bode)의 말을 가슴에 새겼습니다; 몇년간은 좀더 열심히 더 많은 시간을 연구에 투자하려고 노력했지요. 그러니 알게 되더라고요, 내가 한 일이 좀더 많구나. 내 아내 앞에서는 말하고 싶지 않지만, 때로는 아내가 안중에도 없었었습니다; 나는 공부하는 게 필요했어요. 우리가 원하는 바를 이룰려면 많은 것들을 무시해야하지요. 이와 관련해서는 의문의 여지가 없을 것입니다.

<br>

<br>

> redacted @29979245oo
>
> 화상으로 홍콩에 있는 지원자 면접. 이렇게 바로 외국 출신도 면접을 보나보다. 물론 머신러닝 전공이니 가능. 일반 엔지니어는 요즘 비자가 하도 어려워서 해외 채용은 안 함. 모바일은 가능한 듯.
>
> [오전 9:29 - 2018년 5월 7일](https://twitter.com/29979245oo/status/993528229636931584)

<br>

<br>

[프로그래머로서의 성장을 도왔던 태도들](http://ahnheejong.name/articles/becoming-better-programmer/)

<br>

>어떤 리소스를 주로 참고하냐고 물어도 1. 각 기술의 공식문서를 본다 2. MDN 자주 본다 3. 기술 뉴스레터 몇 개를 받아본다 정도. 계속 성장하고 있다 느끼지만 그 성장이 구체적으로 어떻게 이루어지는지 평소에 의식을 잘 못 하고 있는 것도 같다.

<br>

> 프로그래밍 언어를 배운다고 하자. A는 코드는 한 줄도 짜지 않고 스펙을 처음부터 끝까지 전부 읽는다. 한참 후 스펙 읽기를 마쳤지만 간단한 프로그램 하나를 짜는데도 고생한다. 반면 B는 기본 문법만 배운 후 곧바로 문서를 치우고 프로그래밍에 들어간다. 높은 확률로, 문서를 한 번만 읽었어도 안 했을 고생을 헤쳐나가느라 엄청난 시간을 쓰게 된다.
>
> 효율적인 학습을 위해선 A나 B처럼 이론과 실제 코딩 중 한 쪽으로 치우치는 것보다는 이론적인 배경을 쌓는 공부와 그렇게 쌓은 지식을 활용하는 실습, 두 상태를 빠르게 오가는 것이 도움이 된다. 이렇게 학습의 단계를 잘게 나누는 것이 도움이 되는 이유는 크게 두 가지 정도다.
>
> 
>
> 먼저 **짧은 주기의 반복을 통해 빠른 피드백을 얻을 수 있다**. 또한 피드백을 통해 잘못된 결정 – 실제로 무언가를 만들려고 봤더니 잘못된 부분을 보고 있었다든지, 이 도구가 사실 내가 풀려는 문제에 대한 해결책을 풀기에 올바른 솔루션이 아니라든지 등 – 으로부터 빠르게 복구하고 다른 방향을 향할 수 있다. 이런 피드백이 빠르게 일어날수록 더 큰 낭비를 방지할 수 있다.
>
> 둘째로, 이론 – 실습 주기를 한 번 반복 할 때마다 **돌아올 수 있는 체크포인트가 생긴다**. git의 커밋을 생각하면 쉽다. 학습에 있어 주도적으로 이런저런 시도를 해보는 과정은 필수적이다. 게임에서도 체크포인트가 촘촘히 있으면 도전적인 플레이가 가능하듯, 아무리 큰 실수를 해도 돌아올 수 있는 지점이 가까이 있다는 심리적 안정감이 제공되면 더 대범하게 다양한 시도를 해보며 학습할 수 있다.
>
> 앞서 언급한 두 가지 장점을 극대화하기 위해서는 각 이론 – 실습 주기를 끝낸 시점에서 늘 통합 테스트가 가능하도록 학습의 단계를 설계해야 한다. 다르게 표현하자면, 이론을 배우고 해당 이론을 이용해 무언가를 구현했을 때, 구현해낸 결과물이 ‘동작하는’ 상태여야 한다.



<br>

<img src="https://blog.deming.org/wp-content/uploads/2014/11/minimal-viable-product-henrik-kniberg.png">

<br>

> 원해서든 원치 않아서든 코드 리뷰를 받을 상황에 놓였다면, 코드에 대한 비판은 사람에 대한 비판이 아니라는 점을 유념해야 한다. 코드에 대한 정당한 지적을 개인적으로 받아들이지 않고 더 나은 코드를 작성하기 위한 발판으로 삼을 수 있는 사람은 그렇지 않은 이보다 훨씬 빠르게 성장할 수 있다. 또한 전혀 그럴 이유가 없음에도 시간과 노력을 내어 나의 코드를 더 낫게 만들 방법을 같이 고민해준 리뷰어에게 존중과 감사의 마음을 표하는 것을 잊지 말자.

<br>

> 때로는 코드를 작성하는 것보다 코드를 읽는 과정에서 훨씬 많은 것을 배울 수 있다. 이 때 유명한 라이브러리나 언어의 소스 코드, 그리고 표준 라이브러리를 비롯한 API는 쉽게 접근 가능한 좋은 소스다.

<br>

> 개인적으로 언어의 기능만을 이용해서 쉽게 구현할 수 있는 일에 써드파티 라이브러리를 사용하는 걸 싫어하는 것도 이런 이유에서다. 시시각각 바뀌는 세상 속에서 프로그램이 오래 동작하기 위해선 그 모든 구성 부품이 변화에 기민하게 대응해야 한다. 헌데 프로그램이 의존하는 써드파티 라이브러리의 수가 늘수록 그러기가 기하급수적으로 어려워진다. 라이브러리가 제공하는 편리함에는 채무증서가 따라온다.

<br>

> 무언가 배울 때에 가장 근원이 되는 소스 – 소스 코드, 언어 스펙, 라이브러리 공식 문서, 어떤 개념을 처음으로 주창한 이의 글 – 를 찾아보는 습관을 들이는 것이 한 방법이 된다. 무언가를 ‘쉽게’ ‘풀어서’ 설명해주는 블로그 글에는 필연적으로 저자의 재해석이 들어간다. 무엇을 말하고 무엇을 말하지 않을지에 대한 결정은 차치하더라도, 재해석의 단계가 깊어질수록 가장 사실에 가까운 정보로부터 무언가 어긋날 확률이 높아진다.
>
> 자동화할 수 있는 검증의 책무를 사람이 아닌 기계에게 맡기는 것 또한 도움이 된다. 사람이 ‘이 풀 리퀘스트는 기존의 기능을 깨먹지 않았습니다’고 말하는 것을 믿는 대신, 자동화된 회귀 테스트가 검증하게 한다. 문서에 적힌 ‘이 함수를 이런 파라미터를 받습니다’라는 정보를 믿기보다는 정말 그러한지, 혹 잘못 사용하고 있는 곳은 없는지 타입 체커가 자동으로 검사하게 만들면 더 안심할 수 있다.

<br>

> 마지막으로 가장 중요하다 생각하는 내용이다. 어차피 학습에 있어 병목은 나의 시간, 에너지, 이해력이지 외부 정보량이 아니다. 따라서 더 많은 소스 확보가 아니라 큐레이션에 집중해야 한다. 들어오는 정보량이 얼마나 많은지는 중요하지 않은 경우가 많으므로, 인터넷에 올라오는 모든 링크를 읽고 모든 라이브러리에 별을 찍기 위해 집착할 필요가 없다.

<br>

> 그런 좋은 동료를 만나는 데에는 분명 운도 많이 작용한다. 하지만 노력으로 만들 수 있는 변화도 분명 있다. 많은 방법 중 특히 스스로 먼저 좋은 친구가 되려 노력하는 것이 도움이 된다고 생각한다. 내가 원하는 동료를 생각하고, 남들에게 그런 동료가 되기 위해선 어떻게 할 수 있을지 생각해보면 자연스레 ‘다른 이를 돕고, 고통을 덜어줄 수 있는 방법이 뭐가 있을까?’를 고민하게 된다.



<br><br>

[I interviewed at five top companies in Silicon Valley in five days, and luckily got five job offers](https://medium.com/@XiaohanZeng/i-interviewed-at-five-top-companies-in-silicon-valley-in-five-days-and-luckily-got-five-job-offers-25178cf74e0f)

> #### Coding
>
> While I agree that coding interviews might not be the best way to assess all your skills as a developer, there is arguably no better way to tell if you are a good engineer in a short period of time. IMO it is the necessary evil to get you that job.
>
> I mainly used Leetcode and Geeksforgeeks for practicing, but Hackerrank and Lintcode are also good places. I spent several weeks going over common data structures and algorithms, then focused on areas I wasn’t too familiar with, and finally did some frequently seen problems. Due to my time constraints I usually did two problems per day.
>
> Here are some thoughts:
>
> 1. Practice, a lot. There is no way around it.
> 2. But rather than doing all 600 problems on Leetcode, cover all types and spend time understanding each problem thoroughly. I did around 70 problems in total and felt that was enough for me. My thought is that if 70 problems isn’t helpful then you may not be doing it right and 700 won’t be helpful either.
> 3. Go for the hardest ones. After those the rest all become easy.
> 4. If stuck on one problem for over two hours, check out the solutions. More time might not be worth it.
> 5. After solving one problem, check out the solutions. I was often surprised by how smart and elegant some solutions are, especially the Python one-liners.
> 6. Use a language that you are most familiar with and that is common enough to be easily explained to your interviewer.

<br>

[프로그래밍은 레고 조립이 아니다](https://daesan.com/2018/05/programming-is-not-lego)

>프로그래밍은 물론 어렵다. 알고리즘을 익히는 것도, 알고리즘을 구현하는 것도, 컴퓨터 공학의 추상적인 개념들을 이해하는 것도, 프로그래밍 언어 사용에 능숙해지는 것도, 각종 문서를 섭렵하고 다양한 프레임워크와 툴들을 익히는 것도 이미 충분히 어렵다.

<br>

> 결국 스타트업은 산업의 맹점 영역에서 태동할 수 밖에 없다. 미래를 보는 것만으로는 충분하지 않다. 남들이 보지 못하는 미래를 봐야 한다. 그래서 피터 틸은 “당신과 동의하는 사람들이 거의 없는 중요한 진실을 알고 있는게 있느냐?” 고 질문하는 것이다.

<br>

> 해결할만한 가치가 있는 문제란 과연 무엇일가? 내가 사용하는 정의는 “그것을 해결하면 세상이 실제로 바뀌는 문제” 이다. 세상에는 다양한 가치있는 문제들이 많이 있지만, 이 관점에서 해결할만한 가치가 있는 문제는 생각보다 많지 않다.
>
> 좀더 구체적으로 이야기하자면, 해결할만한 가치가 있는 문제란 적지 않은 숫자의 사람들이 실제로 가지고 있는 꽤 커다란 개인적인 문제이다. 중요한 것은 1) 문제의 보편성(=문제를 가진 사람들의 숫자) 2) 문제의 시급성(=새로운 제품이나 서비스를 찾는 사람들의 적극성) 3) 문제의 개인성(=사람들이 자신의 문제로 받아들이는가) 등이다.

<br>

> 예를 들어, 우리 회사가 현재 직면한 두가지 기술적 문제가 있는데, 하나는 리액트 네이티브라는 앱 개발 프레임워크의 안정성/성능 문제 때문에 이 문제를 확실히 해결할 수 있는 대체 프레임워크를 만들어야 한다는 것이고, 다른 하나는 구글 지도 sdk 의 API 가 너무 제한적이라 역시 대체 sdk 를 만들어야 한다는 것이다. 두가지 문제 다 우리가 운영하고 있는 서비스가 기성 레고블록을 outgrow 한 경우이다.
>
> 스타트업에서 문제해결 능력이 중요하다고 말할 때, 개발자에게 요구되는 문제해결 능력이란 이런 것들이다.

<br>

[우리 회사의 개발자 인터뷰](http://blog.kivol.net/post/138587457933/%EC%9A%B0%EB%A6%AC-%ED%9A%8C%EC%82%AC%EC%9D%98-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0)

<br>

[좋은 기술 인터뷰 질문은 어떤 질문인가](http://blog.kivol.net/post/173442457743/%EC%A2%8B%EC%9D%80-%EA%B8%B0%EC%88%A0-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A7%88%EB%AC%B8%EC%9D%80-%EC%96%B4%EB%96%A4-%EC%A7%88%EB%AC%B8%EC%9D%B8%EA%B0%80)

<br>

[HTML5 Video Destruction](http://craftymind.com/factory/html5video/CanvasVideo.html)

<br>

[First IC :)](http://sam.zeloof.xyz/first-ic/)

[Modern Theory of Deep Learning: Why Does It Work so Well](https://medium.com/mlreview/modern-theory-of-deep-learning-why-does-it-works-so-well-9ee1f7fb2808)

<br>[Could AI have saved the cyclist (had I programmed the Uber car)?](https://medium.com/@rebane/could-ai-have-saved-the-cyclist-had-i-programmed-the-uber-car-6e899067fefe)

<br>

[ [실리콘밸리의 한국인 2018] 이 시대의 카멜레온 - 박기상(LinkedIn 시니어 엔지니어) ](http://tv.naver.com/v/2993159)

> [실리콘밸리의 한국인 2018] 이 시대의 카멜레온 - 박기상(LinkedIn 시니어 엔지니어)
>
> - Adaptability - 세상이 너무나 빠르게 변하기 때문에 적응력이 중요하다.
>
> - 적응력을 극대화하기 위한 카멜레온 S-Curve.
>
> <br>
>
> Step #1: Jump
> ‘다양한’ 경험을 쉽게 할 수 있는 곳에 들어간다. 마이너리그여도 상관없다.
>
> 대학 졸업 직후 입사한 회사 XERIUM. 9년 재직함.
> 외주를 주었던 제품에 대한 하드웨어와 소프트웨어 전체를 재설계하기로 결정.
>
> 회사에서의 활동:  <br>
> 기계공학자 <br>
> 전자공학자 <br>
> 소프트웨어 엔지니어 <br>
> Development Engineer ?!?! <br>
> 엔지니어링 매니저 <br>
> 개인 사무실 제공 <br>
> 개인 차량 장기간 지원 <br>
> C-Level 임원들과 잦은 미팅, 출장 <br>
> 대학원 학비 무제한 전액지원 <br>
> 퇴사 후에도 advisor로 월금의 1/2 계속 받음 <br>
> 제1회 혁신상 수상(Chairman’s Innovation Award) <br>
> 특허 3개 출원 <br>
> 무한 자신감 <br>
>
> <br>
>
> Step #2: Growth
> 우리의 감(feelings)은 틀리다. 모든 것은 이론화 되어있다.
>
> 이론: Divide and Conquer
>
> <br>
>
> Step #3: New Opportunities
> 사이드 프로젝트가 당신의 날개가 된다.
>
> 사이드로 만들었던 게임을 통해서 eBay 모바일 부문에 입사.
> 마찬가지로 집에서 사용되는 임베디드 기기 사이트 프로젝트(회로 설계도 직접했고, 특허도 있음)를 통해 Intel의 wearable division에 입사.
>
> “It’s a common catch-22: for jobs that require prior experience, how do you get the experience for the first time? My solution: do the job for free on the side.:
>
> 
>
> - “It is not the strongest of the species that survives, nor the most intelligent that survives. It is the one that is most adaptable to change."
>
> 

<br>